{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"GRIDmas Tree - Web","text":"<p>This is a project based on Standup Maths' 500 LED christmas tree. Watch his video here</p>"},{"location":"#docs","title":"Docs","text":"<p>This is the home for documentation for GRIDmas Tree 2025. Please see the table below for the different sections you can go to.</p> <ul> <li> Color for looks</li> <li> Attributes for pattern settings</li> <li> Utils for making life endurable</li> <li> Examples for example patterns</li> </ul>"},{"location":"docs/attributes/","title":"Attributes","text":"<p>Attributes allow you to change parameters of your pattern while the pattern is running from the web interface, this helps create more dynamic and customizable patterns</p>"},{"location":"docs/attributes/#backend.attribute.Attribute","title":"<code>Attribute</code>","text":"<p>               Bases: <code>Generic[T]</code>, <code>ABC</code></p> <p>Only initialise attributes once in the run function</p> Source code in <code>backend\\attribute.py</code> <pre><code>class Attribute(Generic[T], ABC):\n    \"\"\"Only initialise attributes once in the run function\n    \"\"\"\n\n    def __init__(self, name: str, value: T):\n        self.name = name\n        self.value: T = value\n\n    def get(self) -&gt; T:\n        \"\"\"Get the current value of the attribute\n\n        Returns:\n            T: The value of the attribute\n        \"\"\"\n        return self.value\n\n    def set(self, value: T):\n        \"\"\"Set the value of the range.\n\n           The use of this is discouraged in a pattern\n\n        Args:\n            value (T): The value to set the attribute to\n        \"\"\"\n        self.value = value\n\n    @abstractmethod\n    def pattern_string(self) -&gt; str:\n        ...\n</code></pre>"},{"location":"docs/attributes/#backend.attribute.Attribute.get","title":"<code>get()</code>","text":"<p>Get the current value of the attribute</p> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The value of the attribute</p> Source code in <code>backend\\attribute.py</code> <pre><code>def get(self) -&gt; T:\n    \"\"\"Get the current value of the attribute\n\n    Returns:\n        T: The value of the attribute\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"docs/attributes/#backend.attribute.Attribute.set","title":"<code>set(value)</code>","text":"<p>Set the value of the range.</p> <p>The use of this is discouraged in a pattern</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The value to set the attribute to</p> required Source code in <code>backend\\attribute.py</code> <pre><code>def set(self, value: T):\n    \"\"\"Set the value of the range.\n\n       The use of this is discouraged in a pattern\n\n    Args:\n        value (T): The value to set the attribute to\n    \"\"\"\n    self.value = value\n</code></pre>"},{"location":"docs/attributes/#backend.attribute.ColorAttr","title":"<code>ColorAttr</code>","text":"<p>               Bases: <code>Attribute[Color]</code></p> Source code in <code>backend\\attribute.py</code> <pre><code>class ColorAttr(Attribute[Color]):\n    def __init__(self, name: str, value: Color):\n        \"\"\"Used when you want to accept a color as an input\n\n        Args:\n            name (str): The name displayed on the interface\n            value (Color): The initial starting color\n        \"\"\"\n        super().__init__(name, value)\n        Store.get_store().add(self)\n\n    def pattern_string(self):\n        return \"ColorAttr.html\"\n</code></pre>"},{"location":"docs/attributes/#backend.attribute.ColorAttr.__init__","title":"<code>__init__(name, value)</code>","text":"<p>Used when you want to accept a color as an input</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name displayed on the interface</p> required <code>value</code> <code>Color</code> <p>The initial starting color</p> required Source code in <code>backend\\attribute.py</code> <pre><code>def __init__(self, name: str, value: Color):\n    \"\"\"Used when you want to accept a color as an input\n\n    Args:\n        name (str): The name displayed on the interface\n        value (Color): The initial starting color\n    \"\"\"\n    super().__init__(name, value)\n    Store.get_store().add(self)\n</code></pre>"},{"location":"docs/attributes/#backend.attribute.RangeAttr","title":"<code>RangeAttr</code>","text":"<p>               Bases: <code>Attribute[float]</code></p> Source code in <code>backend\\attribute.py</code> <pre><code>class RangeAttr(Attribute[float]):\n    def __init__(self, name: str,\n                 value: float,\n                 min: float,\n                 max: float,\n                 step: float):\n        \"\"\"Used when you want to accept a value from a pre defined range\n\n        Args:\n            name (str): The name displayed on the interface\n            value (float): The default starting value\n            min (float): The minimum value accepted\n            max (float): The maximum value accepted\n            step (float): The resolution for the range\n        \"\"\"\n        self.min = min\n        self.max = max\n        super().__init__(name, float(clamp(value, self.min, self.max)))\n        self.step = step\n        Store.get_store().add(self)\n\n    def pattern_string(self):\n        return 'RangeAttr.html'\n</code></pre>"},{"location":"docs/attributes/#backend.attribute.RangeAttr.__init__","title":"<code>__init__(name, value, min, max, step)</code>","text":"<p>Used when you want to accept a value from a pre defined range</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name displayed on the interface</p> required <code>value</code> <code>float</code> <p>The default starting value</p> required <code>min</code> <code>float</code> <p>The minimum value accepted</p> required <code>max</code> <code>float</code> <p>The maximum value accepted</p> required <code>step</code> <code>float</code> <p>The resolution for the range</p> required Source code in <code>backend\\attribute.py</code> <pre><code>def __init__(self, name: str,\n             value: float,\n             min: float,\n             max: float,\n             step: float):\n    \"\"\"Used when you want to accept a value from a pre defined range\n\n    Args:\n        name (str): The name displayed on the interface\n        value (float): The default starting value\n        min (float): The minimum value accepted\n        max (float): The maximum value accepted\n        step (float): The resolution for the range\n    \"\"\"\n    self.min = min\n    self.max = max\n    super().__init__(name, float(clamp(value, self.min, self.max)))\n    self.step = step\n    Store.get_store().add(self)\n</code></pre>"},{"location":"docs/colors/","title":"Colors","text":"<p>Colors is a module which contains class definitions for Color and Pixel as well as  helper functions for converting colors between formats</p> <p>I appologise to all british programmers who spell color as colour, but within the programming world we spell it color. This will be the cause of 90% of your bugs if you're not use to programming with the color spelling</p>"},{"location":"docs/colors/#backend.colors.Color","title":"<code>Color</code>","text":"<p>A class representing a color</p> Source code in <code>backend\\colors.py</code> <pre><code>class Color:\n    \"\"\"A class representing a color \"\"\"\n\n    def __init__(self, r: int, g: int, b: int):\n        self._changed = False\n        self._r: int = r &amp; 0xff\n        self._g: int = g &amp; 0xff\n        self._b: int = b &amp; 0xff\n\n        self._L_previous = (0, 0, 0)\n        self._L_target = (0, 0, 0)\n\n        self._L_step = 0\n        self._L_total = 0\n\n        self._L_fn = linear\n\n    @property\n    def r(self):\n        \"\"\"Red component 0-255\"\"\"\n        return self._r\n\n    @property\n    def g(self):\n        \"\"\"Green component 0-255\"\"\"\n        return self._g\n\n    @property\n    def b(self):\n        \"\"\"Blue component 0-255\"\"\"\n        return self._b\n\n    \"\"\"\n    ### Static methods\n    \"\"\"\n\n    @staticmethod\n    def rgb(r: int, g: int, b: int) -&gt; 'Color':\n        \"\"\"An alias for the constructor, values between 0 and 255\"\"\"\n        return Color(r, g, b)\n\n    @staticmethod\n    def hsl(hue: float, sat: float, lig: float) -&gt; 'Color':\n        \"\"\"Get a color from hsl format, values between 0 and 1.0\"\"\"\n        r, g, b = colorsys.hsv_to_rgb(hue, sat, lig)\n        return Color(int(r * 255), int(g * 255), int(b * 255))\n\n    @staticmethod\n    def hex(s: str) -&gt; 'Color':\n        \"\"\"Get a color from a string hex code, in format \"#FFFFFF\" \"\"\"\n        return Color(int(s[1:3], 16), int(s[3:5], 16), int(s[5:7], 16))\n\n    @staticmethod\n    def bit_string(i: int) -&gt; 'Color':\n        \"\"\"Get a color from a string hex code, in format \"#FFFFFF\" \"\"\"\n        r, g, b = int2tuple(i)\n        return Color(r, g, b)\n\n    @staticmethod\n    def random(saturation: float = 1, lightness: float = 0.6) -&gt; 'Color':\n        \"\"\"Generate a random color.\n           The random value is for the Hue. The saturation and lightness can be specified\"\"\"\n        return Color.hsl(random.random(), saturation, lightness)\n\n    @staticmethod\n    def different_from(color: 'Color') -&gt; 'Color':\n        \"\"\"Generate a random color which is different from the color passed into it, maintaining the same hue and saturation\"\"\"\n        h, s, v = colorsys.rgb_to_hsv(*color.to_tuple())\n        newh = ((h * 360 + random.randint(0, 180) + 40) % 360) / 360\n        nr, ng, nb = colorsys.hsv_to_rgb(newh, s, v)\n        return Color(int(nr), int(ng), int(nb))\n\n    @staticmethod\n    def black() -&gt; \"Color\":\n        return Color(0, 0, 0)\n\n    @staticmethod\n    def red() -&gt; \"Color\":\n        return Color(255, 0, 0)\n\n    @staticmethod\n    def orange() -&gt; \"Color\":\n        return Color(252, 81, 8)\n\n    @staticmethod\n    def amber() -&gt; \"Color\":\n        return Color(251, 136, 10)\n\n    @staticmethod\n    def yellow() -&gt; \"Color\":\n        return Color(234, 163, 8)\n\n    @staticmethod\n    def lime() -&gt; \"Color\":\n        return Color(107, 202, 3)\n\n    @staticmethod\n    def green() -&gt; \"Color\":\n        return Color(0, 255, 0)\n\n    @staticmethod\n    def emerald() -&gt; \"Color\":\n        return Color(23, 178, 106)\n\n    @staticmethod\n    def teal() -&gt; \"Color\":\n        return Color(23, 175, 150)\n\n    @staticmethod\n    def cyan() -&gt; \"Color\":\n        return Color(21, 170, 210)\n\n    @staticmethod\n    def sky() -&gt; \"Color\":\n        return Color(20, 146, 241)\n\n    @staticmethod\n    def blue() -&gt; \"Color\":\n        return Color(0, 0, 255)\n\n    @staticmethod\n    def indigo() -&gt; \"Color\":\n        return Color(78, 64, 255)\n\n    @staticmethod\n    def violet() -&gt; \"Color\":\n        return Color(122, 47, 255)\n\n    @staticmethod\n    def purple() -&gt; \"Color\":\n        return Color(155, 30, 255)\n\n    @staticmethod\n    def fuchsia() -&gt; \"Color\":\n        return Color(215, 0, 250)\n\n    @staticmethod\n    def pink() -&gt; \"Color\":\n        \"\"\"pink Get the color pink\n\n        Get the color value of Pink\n\n        Returns:\n            Color: The color pink (240,15,137)\n        \"\"\"\n        return Color(240, 15, 137)\n\n    @staticmethod\n    def rose() -&gt; \"Color\":\n        \"\"\"rose Get the color rose\n\n        Get the color value of Rose\n\n        Returns:\n            Color: The color rose (251,0,69)\n        \"\"\"\n        return Color(251, 0, 69)\n\n    @staticmethod\n    def white() -&gt; \"Color\":\n        \"\"\"white Get the color white\n\n        Get the color value of White\n\n        Returns:\n            Color: The color white (255,255,255)\n        \"\"\"\n        return Color(255, 255, 255)\n\n    @staticmethod\n    def mix(a: \"Color\", b: \"Color\", x: float):\n        return Color(\n            int(a.r + (b.r - a.r) * x),\n            int(a.g + (b.g - a.g) * x),\n            int(a.b + (b.b - a.b) * x)\n        )\n\n    def to_tuple(self) -&gt; tuple[int, int, int]:\n        \"\"\"Returns the tuple of the R, G and B, values between 0 and 255 \"\"\"\n        return (self._r, self._g, self._b)\n\n    def to_hex(self) -&gt; str:\n        \"\"\"to_hex Get the hex value of the current color\n\n        Convert the current color to the hex value representing it and then return\n\n        Returns:\n            str: The current color in the format #RRGGBB\n        \"\"\"\n\n        return tuple2hex((self._r, self._g, self._b))\n\n    def to_hsl(self) -&gt; tuple[float, float, float]:\n        \"\"\"Returns the HSL values of the color, between 0 and 1.0\" \"\"\"\n        return colorsys.rgb_to_hls(self._r, self._g, self._b)\n\n    def to_bit_string(self) -&gt; int:\n        \"\"\"Return the color as an byte string integer, \n       int bitmap encoded as GGGGGGGGRRRRRRRRBBBBBBBB\"\"\"\n        return (self._r &lt;&lt; 8) | (self._g &lt;&lt; 16) | self._b\n\n    def on(self):\n        \"\"\"on Set the color to on\n\n        Sets the color to the fully on state (white, RGB(255,255,255))\n\n        Examples:\n            &gt;&gt;&gt; my_color = Color.red() # Creates a new color that is red\n            &gt;&gt;&gt; my_color.on() # The color is now white (255,255,255)\n        \"\"\"\n        self._r = 255\n        self._g = 255\n        self._b = 255\n\n        self.changed = True\n\n    def off(self):\n        \"\"\"off Set the color to off\n\n        Sets the color to the fully off state (black, RGB(0,0,0))\n\n        Examples:\n            &gt;&gt;&gt; my_color = Color.red() # Creates a new color that is red\n            &gt;&gt;&gt; my_color.off() # The color is now black (0,0,0)\n        \"\"\"\n        self._r = 0\n        self._g = 0\n        self._b = 0\n\n        self._changed = True\n\n    def fade(self, n: float = 1.1):\n        \"\"\"fade Fades a color\n\n        Fade the color slightly n\n\n        Args:\n            n (float, optional): Controls the speed of the fade. The larger the number, the faster it will fade. Values less than 1 cause the color to get brighter to a max color of white. Defaults to 1.1.\n        \"\"\"\n\n        self._r = int(clamp(self.r / n, 0, 255))\n        self._g = int(clamp(self.g / n, 0, 255))\n        self._b = int(clamp(self.b / n, 0, 255))\n\n        self.lerp_reset()\n        self._changed = True\n\n\n    def lerp(self, target: tuple[int, int, int], n: int, override: bool = False, fn: Callable[[float], float] = linear):\n        \"\"\"Linearly interpolate the color from its current color to the target color over n frames.\n\n        Each successive call to lerp will advance the interpolation by a frame. After n amount of calls, it will be the target color. Any change to the target or frames amount will reset the interpolation from the current color. fn provides a way to choose an interpolation method, defaults to linear\n\n        Examples:\n            &gt;&gt;&gt; my_color = Color.red() # (255, 0, 0)\n            &gt;&gt;&gt; my_color.lerp((0, 0, 0), 5) # (205, 0, 0)\n            &gt;&gt;&gt; my_color.lerp((0, 0, 0), 5) # (153, 0, 0)\n            &gt;&gt;&gt; my_color.lerp((0, 0, 0), 5) # (102, 0, 0)\n            &gt;&gt;&gt; my_color.lerp((0, 0, 0), 5) # (51, 0, 0)\n            &gt;&gt;&gt; my_color.lerp((0, 0, 0), 5) # (0, 0, 0)\n            # once reacing the target, lerp has no effect\n            &gt;&gt;&gt; my_color.lerp((0, 0, 0), 5) # (0, 0, 0)\n\n        \"\"\"\n\n        self.set_lerp(target, n, override, fn)\n\n    def lerp_reset(self):\n        \"\"\"lerp_reset Reset to lerp step 0\n\n        This method sets the previous lerp state to the current color, and sets the step number to 0\n        \"\"\"\n        self._L_previous = (self.r, self.g, self.b)\n        self._L_step = 0\n\n    def set_lerp(self, target: tuple[int, int, int], time: int, override: bool = False, fn: Callable[[float], float] = linear):\n        \"\"\"This resets the lerp and starts interpolation to target from current value. Successive calls will not change the target unless override is set to True. Use with cont_lerp to have the same effect as lerp()\"\"\"\n        if (target != self._L_target or self._L_total != time) or override:\n            self.lerp_reset()\n            self._L_target = target\n            self._L_total = time\n            self._L_fn = fn\n\n    def cont_lerp(self):\n        \"\"\"Advanced the lerp one step.\n        \"\"\"\n        if self._L_step == self._L_total:\n            return\n        self._L_step = min(self._L_step + 1, self._L_total)\n        percent = clamp(self._L_step / self._L_total, 0, 1)\n        d = self._L_fn(percent)\n\n        self._r = int(self._L_previous[0] * (1 - d) + self._L_target[0] * d)\n        self._g = int(self._L_previous[1] * (1 - d) + self._L_target[1] * d)\n        self._b = int(self._L_previous[2] * (1 - d) + self._L_target[2] * d)\n\n\n\n    def set(self, c: \"Color\"):\n        \"\"\"Set the color to another color by value\"\"\"\n        self._r = c._r\n        self._g = c._g\n        self._b = c._b\n\n        self.lerp_reset()\n        self.changed = True\n\n    def set_color(self, c: \"Color\"):\n        self._r = c._r\n        self._g = c._g\n        self._b = c._b\n\n        self.lerp_reset()\n        self.changed = True\n\n    def set_rgb(self, r: int, g: int, b: int):        \n        \"\"\"Set the red, green and blue values of the color, values between 0 and 255\"\"\"\n        self._r = r &amp; 0xff\n        self._g = g &amp; 0xff\n        self._b = b &amp; 0xff\n\n        self.lerp_reset()\n        self.changed = True\n\n    def set_hsl(self, hue: float, sat: float, lig: float):\n        \"\"\"Set the color via HSL, values between 0 and 1.0\"\"\"\n        r, g, b = colorsys.hsv_to_rgb(hue, sat, lig)\n        self._r = int(r * 255)\n        self._g = int(g * 255)\n        self._b = int(b * 255)\n\n        self.lerp_reset()\n        self.changed = True\n\n    def set_hex(self, s: str):\n        \"\"\"Set the color with a string hex code, in format \"#FFFFFF\" \"\"\"\n        self._r, self._g, self._b = int(s[1:3], 16), int(s[3:5], 16), int(s[5:7], 16)\n\n        self.lerp_reset()\n        self.changed = True\n\n    def set_bit_string(self, i: int):\n        \"\"\"Set the color with a string hex code, in format \"#FFFFFF\" \"\"\"\n        self._r, self._g, self._b = int2tuple(i)\n\n        self.lerp_reset()\n        self.changed = True\n\n    def set_random(self, saturation: float = 1, lightness: float = 0.6):\n        \"\"\"Set the color to a random color.\n           The random value is for the Hue. The saturation and lightness can be specified\"\"\"\n        self.set_hsl(random.random(), saturation, lightness)\n\n        self.lerp_reset()\n        self.changed = True\n\n    def set_different_from(self, color: 'Color'):\n        \"\"\"Set the color to a random color which is different from the color passed into it, maintaining the same hue and saturation\"\"\"\n        h, s, v = color.to_hsl()\n        newh = ((h * 360 + random.randint(0, 180) + 40) % 360) / 360\n        self.set_hsl(newh, s, v) # handles the changed and lerp reset\n\n    def set_different_from_self(self):\n        \"\"\"Set the color to a random color which is different to the current color, maintaining the same hue and saturation\"\"\"\n        h, s, v = self.to_hsl()\n        newh = ((h * 360 + random.randint(0, 180) + 40) % 360) / 360\n        self.set_hsl(newh, s, v) # handles the changed and lerp reset\n\n    def set_black(self):\n        self._r, self._g, self._b = 0, 0, 0\n\n    def set_red(self):\n        self._r, self._g, self._b = 255, 0, 0\n\n    def set_orange(self):\n        self._r, self._g, self._b = 252, 81, 8\n\n    def set_amber(self):\n        self._r, self._g, self._b = 251, 136, 10\n\n    def set_yellow(self):\n        self._r, self._g, self._b = 234, 163, 8\n\n    def set_lime(self):\n        self._r, self._g, self._b = 107, 202, 3\n\n    def set_green(self):\n        self._r, self._g, self._b = 0, 255, 0\n\n    def set_emerald(self):\n        self._r, self._g, self._b = 23, 178, 106\n\n    def set_teal(self):\n        self._r, self._g, self._b = 23, 175, 150\n\n    def set_cyan(self):\n        self._r, self._g, self._b = 21, 170, 210\n\n    def set_sky(self):\n        self._r, self._g, self._b = 20, 146, 241\n\n    def set_blue(self):\n        self._r, self._g, self._b = 0, 0, 255\n\n    def set_indigo(self):\n        self._r, self._g, self._b = 78, 64, 255\n\n    def set_violet(self):\n        self._r, self._g, self._b = 122, 47, 255\n\n    def set_purple(self):\n        self._r, self._g, self._b = 155, 30, 255\n\n    def set_fuchsia(self):\n        self._r, self._g, self._b = 215, 0, 250\n\n    def set_pink(self):\n        self._r, self._g, self._b = 240, 15, 137\n\n    def set_rose(self):\n        self._r, self._g, self._b = 251, 0, 69\n\n    def set_white(self):\n        self._r, self._g, self._b = 255, 255, 255\n</code></pre>"},{"location":"docs/colors/#backend.colors.Color.b","title":"<code>b</code>  <code>property</code>","text":"<p>Blue component 0-255</p>"},{"location":"docs/colors/#backend.colors.Color.g","title":"<code>g</code>  <code>property</code>","text":"<p>Green component 0-255</p>"},{"location":"docs/colors/#backend.colors.Color.r","title":"<code>r</code>  <code>property</code>","text":"<p>Red component 0-255</p>"},{"location":"docs/colors/#backend.colors.Color.bit_string","title":"<code>bit_string(i)</code>  <code>staticmethod</code>","text":"<p>Get a color from a string hex code, in format \"#FFFFFF\"</p> Source code in <code>backend\\colors.py</code> <pre><code>@staticmethod\ndef bit_string(i: int) -&gt; 'Color':\n    \"\"\"Get a color from a string hex code, in format \"#FFFFFF\" \"\"\"\n    r, g, b = int2tuple(i)\n    return Color(r, g, b)\n</code></pre>"},{"location":"docs/colors/#backend.colors.Color.cont_lerp","title":"<code>cont_lerp()</code>","text":"<p>Advanced the lerp one step.</p> Source code in <code>backend\\colors.py</code> <pre><code>def cont_lerp(self):\n    \"\"\"Advanced the lerp one step.\n    \"\"\"\n    if self._L_step == self._L_total:\n        return\n    self._L_step = min(self._L_step + 1, self._L_total)\n    percent = clamp(self._L_step / self._L_total, 0, 1)\n    d = self._L_fn(percent)\n\n    self._r = int(self._L_previous[0] * (1 - d) + self._L_target[0] * d)\n    self._g = int(self._L_previous[1] * (1 - d) + self._L_target[1] * d)\n    self._b = int(self._L_previous[2] * (1 - d) + self._L_target[2] * d)\n</code></pre>"},{"location":"docs/colors/#backend.colors.Color.different_from","title":"<code>different_from(color)</code>  <code>staticmethod</code>","text":"<p>Generate a random color which is different from the color passed into it, maintaining the same hue and saturation</p> Source code in <code>backend\\colors.py</code> <pre><code>@staticmethod\ndef different_from(color: 'Color') -&gt; 'Color':\n    \"\"\"Generate a random color which is different from the color passed into it, maintaining the same hue and saturation\"\"\"\n    h, s, v = colorsys.rgb_to_hsv(*color.to_tuple())\n    newh = ((h * 360 + random.randint(0, 180) + 40) % 360) / 360\n    nr, ng, nb = colorsys.hsv_to_rgb(newh, s, v)\n    return Color(int(nr), int(ng), int(nb))\n</code></pre>"},{"location":"docs/colors/#backend.colors.Color.fade","title":"<code>fade(n=1.1)</code>","text":"<p>fade Fades a color</p> <p>Fade the color slightly n</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>float</code> <p>Controls the speed of the fade. The larger the number, the faster it will fade. Values less than 1 cause the color to get brighter to a max color of white. Defaults to 1.1.</p> <code>1.1</code> Source code in <code>backend\\colors.py</code> <pre><code>def fade(self, n: float = 1.1):\n    \"\"\"fade Fades a color\n\n    Fade the color slightly n\n\n    Args:\n        n (float, optional): Controls the speed of the fade. The larger the number, the faster it will fade. Values less than 1 cause the color to get brighter to a max color of white. Defaults to 1.1.\n    \"\"\"\n\n    self._r = int(clamp(self.r / n, 0, 255))\n    self._g = int(clamp(self.g / n, 0, 255))\n    self._b = int(clamp(self.b / n, 0, 255))\n\n    self.lerp_reset()\n    self._changed = True\n</code></pre>"},{"location":"docs/colors/#backend.colors.Color.hex","title":"<code>hex(s)</code>  <code>staticmethod</code>","text":"<p>Get a color from a string hex code, in format \"#FFFFFF\"</p> Source code in <code>backend\\colors.py</code> <pre><code>@staticmethod\ndef hex(s: str) -&gt; 'Color':\n    \"\"\"Get a color from a string hex code, in format \"#FFFFFF\" \"\"\"\n    return Color(int(s[1:3], 16), int(s[3:5], 16), int(s[5:7], 16))\n</code></pre>"},{"location":"docs/colors/#backend.colors.Color.hsl","title":"<code>hsl(hue, sat, lig)</code>  <code>staticmethod</code>","text":"<p>Get a color from hsl format, values between 0 and 1.0</p> Source code in <code>backend\\colors.py</code> <pre><code>@staticmethod\ndef hsl(hue: float, sat: float, lig: float) -&gt; 'Color':\n    \"\"\"Get a color from hsl format, values between 0 and 1.0\"\"\"\n    r, g, b = colorsys.hsv_to_rgb(hue, sat, lig)\n    return Color(int(r * 255), int(g * 255), int(b * 255))\n</code></pre>"},{"location":"docs/colors/#backend.colors.Color.lerp","title":"<code>lerp(target, n, override=False, fn=linear)</code>","text":"<p>Linearly interpolate the color from its current color to the target color over n frames.</p> <p>Each successive call to lerp will advance the interpolation by a frame. After n amount of calls, it will be the target color. Any change to the target or frames amount will reset the interpolation from the current color. fn provides a way to choose an interpolation method, defaults to linear</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; my_color = Color.red() # (255, 0, 0)\n&gt;&gt;&gt; my_color.lerp((0, 0, 0), 5) # (205, 0, 0)\n&gt;&gt;&gt; my_color.lerp((0, 0, 0), 5) # (153, 0, 0)\n&gt;&gt;&gt; my_color.lerp((0, 0, 0), 5) # (102, 0, 0)\n&gt;&gt;&gt; my_color.lerp((0, 0, 0), 5) # (51, 0, 0)\n&gt;&gt;&gt; my_color.lerp((0, 0, 0), 5) # (0, 0, 0)\n# once reacing the target, lerp has no effect\n&gt;&gt;&gt; my_color.lerp((0, 0, 0), 5) # (0, 0, 0)\n</code></pre> Source code in <code>backend\\colors.py</code> <pre><code>def lerp(self, target: tuple[int, int, int], n: int, override: bool = False, fn: Callable[[float], float] = linear):\n    \"\"\"Linearly interpolate the color from its current color to the target color over n frames.\n\n    Each successive call to lerp will advance the interpolation by a frame. After n amount of calls, it will be the target color. Any change to the target or frames amount will reset the interpolation from the current color. fn provides a way to choose an interpolation method, defaults to linear\n\n    Examples:\n        &gt;&gt;&gt; my_color = Color.red() # (255, 0, 0)\n        &gt;&gt;&gt; my_color.lerp((0, 0, 0), 5) # (205, 0, 0)\n        &gt;&gt;&gt; my_color.lerp((0, 0, 0), 5) # (153, 0, 0)\n        &gt;&gt;&gt; my_color.lerp((0, 0, 0), 5) # (102, 0, 0)\n        &gt;&gt;&gt; my_color.lerp((0, 0, 0), 5) # (51, 0, 0)\n        &gt;&gt;&gt; my_color.lerp((0, 0, 0), 5) # (0, 0, 0)\n        # once reacing the target, lerp has no effect\n        &gt;&gt;&gt; my_color.lerp((0, 0, 0), 5) # (0, 0, 0)\n\n    \"\"\"\n\n    self.set_lerp(target, n, override, fn)\n</code></pre>"},{"location":"docs/colors/#backend.colors.Color.lerp_reset","title":"<code>lerp_reset()</code>","text":"<p>lerp_reset Reset to lerp step 0</p> <p>This method sets the previous lerp state to the current color, and sets the step number to 0</p> Source code in <code>backend\\colors.py</code> <pre><code>def lerp_reset(self):\n    \"\"\"lerp_reset Reset to lerp step 0\n\n    This method sets the previous lerp state to the current color, and sets the step number to 0\n    \"\"\"\n    self._L_previous = (self.r, self.g, self.b)\n    self._L_step = 0\n</code></pre>"},{"location":"docs/colors/#backend.colors.Color.off","title":"<code>off()</code>","text":"<p>off Set the color to off</p> <p>Sets the color to the fully off state (black, RGB(0,0,0))</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; my_color = Color.red() # Creates a new color that is red\n&gt;&gt;&gt; my_color.off() # The color is now black (0,0,0)\n</code></pre> Source code in <code>backend\\colors.py</code> <pre><code>def off(self):\n    \"\"\"off Set the color to off\n\n    Sets the color to the fully off state (black, RGB(0,0,0))\n\n    Examples:\n        &gt;&gt;&gt; my_color = Color.red() # Creates a new color that is red\n        &gt;&gt;&gt; my_color.off() # The color is now black (0,0,0)\n    \"\"\"\n    self._r = 0\n    self._g = 0\n    self._b = 0\n\n    self._changed = True\n</code></pre>"},{"location":"docs/colors/#backend.colors.Color.on","title":"<code>on()</code>","text":"<p>on Set the color to on</p> <p>Sets the color to the fully on state (white, RGB(255,255,255))</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; my_color = Color.red() # Creates a new color that is red\n&gt;&gt;&gt; my_color.on() # The color is now white (255,255,255)\n</code></pre> Source code in <code>backend\\colors.py</code> <pre><code>def on(self):\n    \"\"\"on Set the color to on\n\n    Sets the color to the fully on state (white, RGB(255,255,255))\n\n    Examples:\n        &gt;&gt;&gt; my_color = Color.red() # Creates a new color that is red\n        &gt;&gt;&gt; my_color.on() # The color is now white (255,255,255)\n    \"\"\"\n    self._r = 255\n    self._g = 255\n    self._b = 255\n\n    self.changed = True\n</code></pre>"},{"location":"docs/colors/#backend.colors.Color.pink","title":"<code>pink()</code>  <code>staticmethod</code>","text":"<p>pink Get the color pink</p> <p>Get the color value of Pink</p> <p>Returns:</p> Name Type Description <code>Color</code> <code>Color</code> <p>The color pink (240,15,137)</p> Source code in <code>backend\\colors.py</code> <pre><code>@staticmethod\ndef pink() -&gt; \"Color\":\n    \"\"\"pink Get the color pink\n\n    Get the color value of Pink\n\n    Returns:\n        Color: The color pink (240,15,137)\n    \"\"\"\n    return Color(240, 15, 137)\n</code></pre>"},{"location":"docs/colors/#backend.colors.Color.random","title":"<code>random(saturation=1, lightness=0.6)</code>  <code>staticmethod</code>","text":"<p>Generate a random color. The random value is for the Hue. The saturation and lightness can be specified</p> Source code in <code>backend\\colors.py</code> <pre><code>@staticmethod\ndef random(saturation: float = 1, lightness: float = 0.6) -&gt; 'Color':\n    \"\"\"Generate a random color.\n       The random value is for the Hue. The saturation and lightness can be specified\"\"\"\n    return Color.hsl(random.random(), saturation, lightness)\n</code></pre>"},{"location":"docs/colors/#backend.colors.Color.rgb","title":"<code>rgb(r, g, b)</code>  <code>staticmethod</code>","text":"<p>An alias for the constructor, values between 0 and 255</p> Source code in <code>backend\\colors.py</code> <pre><code>@staticmethod\ndef rgb(r: int, g: int, b: int) -&gt; 'Color':\n    \"\"\"An alias for the constructor, values between 0 and 255\"\"\"\n    return Color(r, g, b)\n</code></pre>"},{"location":"docs/colors/#backend.colors.Color.rose","title":"<code>rose()</code>  <code>staticmethod</code>","text":"<p>rose Get the color rose</p> <p>Get the color value of Rose</p> <p>Returns:</p> Name Type Description <code>Color</code> <code>Color</code> <p>The color rose (251,0,69)</p> Source code in <code>backend\\colors.py</code> <pre><code>@staticmethod\ndef rose() -&gt; \"Color\":\n    \"\"\"rose Get the color rose\n\n    Get the color value of Rose\n\n    Returns:\n        Color: The color rose (251,0,69)\n    \"\"\"\n    return Color(251, 0, 69)\n</code></pre>"},{"location":"docs/colors/#backend.colors.Color.set","title":"<code>set(c)</code>","text":"<p>Set the color to another color by value</p> Source code in <code>backend\\colors.py</code> <pre><code>def set(self, c: \"Color\"):\n    \"\"\"Set the color to another color by value\"\"\"\n    self._r = c._r\n    self._g = c._g\n    self._b = c._b\n\n    self.lerp_reset()\n    self.changed = True\n</code></pre>"},{"location":"docs/colors/#backend.colors.Color.set_bit_string","title":"<code>set_bit_string(i)</code>","text":"<p>Set the color with a string hex code, in format \"#FFFFFF\"</p> Source code in <code>backend\\colors.py</code> <pre><code>def set_bit_string(self, i: int):\n    \"\"\"Set the color with a string hex code, in format \"#FFFFFF\" \"\"\"\n    self._r, self._g, self._b = int2tuple(i)\n\n    self.lerp_reset()\n    self.changed = True\n</code></pre>"},{"location":"docs/colors/#backend.colors.Color.set_different_from","title":"<code>set_different_from(color)</code>","text":"<p>Set the color to a random color which is different from the color passed into it, maintaining the same hue and saturation</p> Source code in <code>backend\\colors.py</code> <pre><code>def set_different_from(self, color: 'Color'):\n    \"\"\"Set the color to a random color which is different from the color passed into it, maintaining the same hue and saturation\"\"\"\n    h, s, v = color.to_hsl()\n    newh = ((h * 360 + random.randint(0, 180) + 40) % 360) / 360\n    self.set_hsl(newh, s, v) # handles the changed and lerp reset\n</code></pre>"},{"location":"docs/colors/#backend.colors.Color.set_different_from_self","title":"<code>set_different_from_self()</code>","text":"<p>Set the color to a random color which is different to the current color, maintaining the same hue and saturation</p> Source code in <code>backend\\colors.py</code> <pre><code>def set_different_from_self(self):\n    \"\"\"Set the color to a random color which is different to the current color, maintaining the same hue and saturation\"\"\"\n    h, s, v = self.to_hsl()\n    newh = ((h * 360 + random.randint(0, 180) + 40) % 360) / 360\n    self.set_hsl(newh, s, v) # handles the changed and lerp reset\n</code></pre>"},{"location":"docs/colors/#backend.colors.Color.set_hex","title":"<code>set_hex(s)</code>","text":"<p>Set the color with a string hex code, in format \"#FFFFFF\"</p> Source code in <code>backend\\colors.py</code> <pre><code>def set_hex(self, s: str):\n    \"\"\"Set the color with a string hex code, in format \"#FFFFFF\" \"\"\"\n    self._r, self._g, self._b = int(s[1:3], 16), int(s[3:5], 16), int(s[5:7], 16)\n\n    self.lerp_reset()\n    self.changed = True\n</code></pre>"},{"location":"docs/colors/#backend.colors.Color.set_hsl","title":"<code>set_hsl(hue, sat, lig)</code>","text":"<p>Set the color via HSL, values between 0 and 1.0</p> Source code in <code>backend\\colors.py</code> <pre><code>def set_hsl(self, hue: float, sat: float, lig: float):\n    \"\"\"Set the color via HSL, values between 0 and 1.0\"\"\"\n    r, g, b = colorsys.hsv_to_rgb(hue, sat, lig)\n    self._r = int(r * 255)\n    self._g = int(g * 255)\n    self._b = int(b * 255)\n\n    self.lerp_reset()\n    self.changed = True\n</code></pre>"},{"location":"docs/colors/#backend.colors.Color.set_lerp","title":"<code>set_lerp(target, time, override=False, fn=linear)</code>","text":"<p>This resets the lerp and starts interpolation to target from current value. Successive calls will not change the target unless override is set to True. Use with cont_lerp to have the same effect as lerp()</p> Source code in <code>backend\\colors.py</code> <pre><code>def set_lerp(self, target: tuple[int, int, int], time: int, override: bool = False, fn: Callable[[float], float] = linear):\n    \"\"\"This resets the lerp and starts interpolation to target from current value. Successive calls will not change the target unless override is set to True. Use with cont_lerp to have the same effect as lerp()\"\"\"\n    if (target != self._L_target or self._L_total != time) or override:\n        self.lerp_reset()\n        self._L_target = target\n        self._L_total = time\n        self._L_fn = fn\n</code></pre>"},{"location":"docs/colors/#backend.colors.Color.set_random","title":"<code>set_random(saturation=1, lightness=0.6)</code>","text":"<p>Set the color to a random color. The random value is for the Hue. The saturation and lightness can be specified</p> Source code in <code>backend\\colors.py</code> <pre><code>def set_random(self, saturation: float = 1, lightness: float = 0.6):\n    \"\"\"Set the color to a random color.\n       The random value is for the Hue. The saturation and lightness can be specified\"\"\"\n    self.set_hsl(random.random(), saturation, lightness)\n\n    self.lerp_reset()\n    self.changed = True\n</code></pre>"},{"location":"docs/colors/#backend.colors.Color.set_rgb","title":"<code>set_rgb(r, g, b)</code>","text":"<p>Set the red, green and blue values of the color, values between 0 and 255</p> Source code in <code>backend\\colors.py</code> <pre><code>def set_rgb(self, r: int, g: int, b: int):        \n    \"\"\"Set the red, green and blue values of the color, values between 0 and 255\"\"\"\n    self._r = r &amp; 0xff\n    self._g = g &amp; 0xff\n    self._b = b &amp; 0xff\n\n    self.lerp_reset()\n    self.changed = True\n</code></pre>"},{"location":"docs/colors/#backend.colors.Color.to_bit_string","title":"<code>to_bit_string()</code>","text":"<p>Return the color as an byte string integer,  int bitmap encoded as GGGGGGGGRRRRRRRRBBBBBBBB</p> Source code in <code>backend\\colors.py</code> <pre><code>def to_bit_string(self) -&gt; int:\n    \"\"\"Return the color as an byte string integer, \n   int bitmap encoded as GGGGGGGGRRRRRRRRBBBBBBBB\"\"\"\n    return (self._r &lt;&lt; 8) | (self._g &lt;&lt; 16) | self._b\n</code></pre>"},{"location":"docs/colors/#backend.colors.Color.to_hex","title":"<code>to_hex()</code>","text":"<p>to_hex Get the hex value of the current color</p> <p>Convert the current color to the hex value representing it and then return</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The current color in the format #RRGGBB</p> Source code in <code>backend\\colors.py</code> <pre><code>def to_hex(self) -&gt; str:\n    \"\"\"to_hex Get the hex value of the current color\n\n    Convert the current color to the hex value representing it and then return\n\n    Returns:\n        str: The current color in the format #RRGGBB\n    \"\"\"\n\n    return tuple2hex((self._r, self._g, self._b))\n</code></pre>"},{"location":"docs/colors/#backend.colors.Color.to_hsl","title":"<code>to_hsl()</code>","text":"<p>Returns the HSL values of the color, between 0 and 1.0\"</p> Source code in <code>backend\\colors.py</code> <pre><code>def to_hsl(self) -&gt; tuple[float, float, float]:\n    \"\"\"Returns the HSL values of the color, between 0 and 1.0\" \"\"\"\n    return colorsys.rgb_to_hls(self._r, self._g, self._b)\n</code></pre>"},{"location":"docs/colors/#backend.colors.Color.to_tuple","title":"<code>to_tuple()</code>","text":"<p>Returns the tuple of the R, G and B, values between 0 and 255</p> Source code in <code>backend\\colors.py</code> <pre><code>def to_tuple(self) -&gt; tuple[int, int, int]:\n    \"\"\"Returns the tuple of the R, G and B, values between 0 and 255 \"\"\"\n    return (self._r, self._g, self._b)\n</code></pre>"},{"location":"docs/colors/#backend.colors.Color.white","title":"<code>white()</code>  <code>staticmethod</code>","text":"<p>white Get the color white</p> <p>Get the color value of White</p> <p>Returns:</p> Name Type Description <code>Color</code> <code>Color</code> <p>The color white (255,255,255)</p> Source code in <code>backend\\colors.py</code> <pre><code>@staticmethod\ndef white() -&gt; \"Color\":\n    \"\"\"white Get the color white\n\n    Get the color value of White\n\n    Returns:\n        Color: The color white (255,255,255)\n    \"\"\"\n    return Color(255, 255, 255)\n</code></pre>"},{"location":"docs/colors/#backend.colors.Pixel","title":"<code>Pixel</code>","text":"<p>               Bases: <code>Color</code></p> <p>The pixel class extends the Color class by adding 3D coordinates to a color. All the same methods and attributes exist on a pixel so they act the same way</p> <p>Coordintates are in the GIFT format so range between -1 and 1 on X and Y axis, and 0 and tree.height on the Z axis</p> <p>Attributes: x: float: The x axis position y: float: The y axis position z: float: The z axis position a: float: The polar angle in radians from the x axis going clockwise when looking downward on the tree d: float: The polar distance from the Z axis (trunk)</p> Source code in <code>backend\\colors.py</code> <pre><code>class Pixel(Color):\n    \"\"\"The pixel class extends the Color class by adding 3D coordinates to a color.\n       All the same methods and attributes exist on a pixel so they act the same way\n\n       Coordintates are in the GIFT format so range between -1 and 1 on X and Y axis,\n       and 0 and tree.height on the Z axis\n\n       Attributes:\n       x: float: The x axis position\n       y: float: The y axis position\n       z: float: The z axis position\n       a: float: The polar angle in radians from the x axis going clockwise when looking downward on the tree\n       d: float: The polar distance from the Z axis (trunk)\n    \"\"\"\n\n    def __init__(self, id: int, coord: tuple[float, float, float], tree: \"Tree\", color: Color = Color.black()):\n        super().__init__(*color.to_tuple())\n        self._id = id\n\n        self._x = coord[0]\n        self._y = coord[1]\n        self._z = coord[2]\n\n        self._a = math.atan2(self._y, self._x)\n        self._d = math.sqrt(self._y ** 2 + self._x ** 2)\n\n        self._tree = tree\n\n    @property\n    def id(self) -&gt; int:\n        \"\"\"The id in the LED sequence\"\"\"\n        return self._id\n\n    @property\n    def x(self) -&gt; float:\n        \"\"\"The X coordinate, left (-1) to right (+1)\"\"\"\n        return self._x\n\n    @property\n    def y(self) -&gt; float:\n        \"\"\"The Y coordinate, front (+1) to back (-1)\"\"\"\n        return self._y\n\n    @property\n    def z(self) -&gt; float:\n        \"\"\"The Z coordinate bottom (0) to top (height())\"\"\"\n        return self._z\n\n    @property\n    def xyz(self) -&gt; tuple[float, float, float]:\n        \"\"\"The tuple containing the xyz coordinates\"\"\"\n        return (self._x, self._y, self._z)\n\n    @property\n    def a(self) -&gt; float:\n        \"\"\"The angle clockwise from the x+ direction around the tree\"\"\"\n        return self._a\n\n    @property\n    def d(self) -&gt; float:\n        \"\"\"The distance from the center line (trunk) of the tree\"\"\"\n        return self._d\n\n    def distance_to(self, p: \"Pixel\") -&gt; float:\n        \"\"\"Find the distance to the passed pixel\"\"\"\n        return self._tree.distances[self._id][p.id]\n\n    def nearest(self, n: int) -&gt; list[tuple[\"Pixel\", float]]:\n        \"\"\"Find the distance to the passed pixel\"\"\"\n        return self._tree.pixel_distance_matrix[self._id][:n]\n\n    def within(self, d: float) -&gt; list[\"Pixel\"]:\n        \"\"\"Find all pixels that are within a certain radius\"\"\"\n        left = 0\n        right = len(self._tree.pixels) - 1\n        while left &lt; right:\n            mid = (left + right) // 2\n            if self._tree.pixel_distance_matrix[self._id][mid][1] &lt; d:\n                left = mid + 1\n            else:\n                right = mid\n        return self._tree.pixel_distance_matrix[self._id][:left]\n</code></pre>"},{"location":"docs/colors/#backend.colors.Pixel.a","title":"<code>a</code>  <code>property</code>","text":"<p>The angle clockwise from the x+ direction around the tree</p>"},{"location":"docs/colors/#backend.colors.Pixel.d","title":"<code>d</code>  <code>property</code>","text":"<p>The distance from the center line (trunk) of the tree</p>"},{"location":"docs/colors/#backend.colors.Pixel.id","title":"<code>id</code>  <code>property</code>","text":"<p>The id in the LED sequence</p>"},{"location":"docs/colors/#backend.colors.Pixel.x","title":"<code>x</code>  <code>property</code>","text":"<p>The X coordinate, left (-1) to right (+1)</p>"},{"location":"docs/colors/#backend.colors.Pixel.xyz","title":"<code>xyz</code>  <code>property</code>","text":"<p>The tuple containing the xyz coordinates</p>"},{"location":"docs/colors/#backend.colors.Pixel.y","title":"<code>y</code>  <code>property</code>","text":"<p>The Y coordinate, front (+1) to back (-1)</p>"},{"location":"docs/colors/#backend.colors.Pixel.z","title":"<code>z</code>  <code>property</code>","text":"<p>The Z coordinate bottom (0) to top (height())</p>"},{"location":"docs/colors/#backend.colors.Pixel.distance_to","title":"<code>distance_to(p)</code>","text":"<p>Find the distance to the passed pixel</p> Source code in <code>backend\\colors.py</code> <pre><code>def distance_to(self, p: \"Pixel\") -&gt; float:\n    \"\"\"Find the distance to the passed pixel\"\"\"\n    return self._tree.distances[self._id][p.id]\n</code></pre>"},{"location":"docs/colors/#backend.colors.Pixel.nearest","title":"<code>nearest(n)</code>","text":"<p>Find the distance to the passed pixel</p> Source code in <code>backend\\colors.py</code> <pre><code>def nearest(self, n: int) -&gt; list[tuple[\"Pixel\", float]]:\n    \"\"\"Find the distance to the passed pixel\"\"\"\n    return self._tree.pixel_distance_matrix[self._id][:n]\n</code></pre>"},{"location":"docs/colors/#backend.colors.Pixel.within","title":"<code>within(d)</code>","text":"<p>Find all pixels that are within a certain radius</p> Source code in <code>backend\\colors.py</code> <pre><code>def within(self, d: float) -&gt; list[\"Pixel\"]:\n    \"\"\"Find all pixels that are within a certain radius\"\"\"\n    left = 0\n    right = len(self._tree.pixels) - 1\n    while left &lt; right:\n        mid = (left + right) // 2\n        if self._tree.pixel_distance_matrix[self._id][mid][1] &lt; d:\n            left = mid + 1\n        else:\n            right = mid\n    return self._tree.pixel_distance_matrix[self._id][:left]\n</code></pre>"},{"location":"docs/colors/#backend.colors.hex2tuple","title":"<code>hex2tuple(h)</code>","text":"<p>Convert a hex string to an RGB tuple</p> Source code in <code>backend\\colors.py</code> <pre><code>def hex2tuple(h: str) -&gt; tuple[int, int, int]:\n    \"\"\"Convert a hex string to an RGB tuple\"\"\"\n    return (int(h[1:3], 16), int(h[3:5], 16), int(h[5:7], 16))\n</code></pre>"},{"location":"docs/colors/#backend.colors.int2tuple","title":"<code>int2tuple(c)</code>","text":"<p>conver the 24bit encoded int to tuple of R, G, and B. int bitmap encoded as GGGGGGGGRRRRRRRRBBBBBBBB</p> Source code in <code>backend\\colors.py</code> <pre><code>def int2tuple(c: int) -&gt; tuple[int, int, int]:\n    \"\"\"conver the 24bit encoded int to tuple of R, G, and B.\n       int bitmap encoded as GGGGGGGGRRRRRRRRBBBBBBBB\"\"\"\n    return ((c &gt;&gt; 8) &amp; 0xff, (c &gt;&gt; 16) &amp; 0xff, c &amp; 0xff)\n</code></pre>"},{"location":"docs/colors/#backend.colors.tuple2hex","title":"<code>tuple2hex(t)</code>","text":"<p>Convert an RGB tuple to hex string</p> Source code in <code>backend\\colors.py</code> <pre><code>def tuple2hex(t: tuple[int, int, int]) -&gt; str:\n    \"\"\"Convert an RGB tuple to hex string \"\"\"\n    return '#%02x%02x%02x' % t\n</code></pre>"},{"location":"docs/colors/#backend.colors.tuple2int","title":"<code>tuple2int(t)</code>","text":"<p>conver rgb to 24bit encoded int. int bitmap encoded as GGGGGGGGRRRRRRRRBBBBBBBB</p> Source code in <code>backend\\colors.py</code> <pre><code>def tuple2int(t: tuple[int, int, int]) -&gt; int:\n    \"\"\"conver rgb to 24bit encoded int.\n       int bitmap encoded as GGGGGGGGRRRRRRRRBBBBBBBB\n    \"\"\"\n    return (t[0] &lt;&lt; 8) | (t[1] &lt;&lt; 16) | t[2]\n</code></pre>"},{"location":"docs/main/","title":"Main","text":"<p>This is the main entry point for GRIDmas Tree.</p>"},{"location":"docs/main/#backend.main.__author__","title":"<code>__author__ = 'Cairan Cook'</code>  <code>module-attribute</code>","text":"<p>Code Author</p>"},{"location":"docs/main/#backend.main.__documenter__","title":"<code>__documenter__ = 'Owen Plimer'</code>  <code>module-attribute</code>","text":"<p>Documentation author</p>"},{"location":"docs/patternManager/","title":"Pattern Manager","text":"<p>A collection of the pattern manager class and its helper functions</p>"},{"location":"docs/patternManager/#backend.pattern_manager.PatternManager","title":"<code>PatternManager</code>","text":"<p>Manages patterns for the tree</p> <p>The pattern manager is in charge of loading, parsing, storing and recalling pattern files</p> Warning <p>This module is intended for internal use only. You do not need to use any of this in your pattern code</p> Source code in <code>backend\\pattern_manager.py</code> <pre><code>class PatternManager:\n    \"\"\" Manages patterns for the tree\n\n    The pattern manager is in charge of loading, parsing, storing and recalling pattern files\n\n    Warning:\n        This module is intended for internal use only. You do not need to use any of this in your pattern code\n    \"\"\"\n\n    def __init__(self, pattern_dir: str):\n        \"\"\"__init__ Initialise the pattern manager\n\n        Create a new instance of the pattern manager and load the `on` pattern\n\n        Args:\n            pattern_dir (str): The directory to search for pattern files. The search is carried out automatically\n        \"\"\"\n        self.load_patterns(pattern_dir)\n\n        self.currentPattern = self.patterns[\"on\"]\n\n        self.generator = None\n\n    def load_patterns(self, pattern_dir: str):\n        \"\"\"load_patterns Loads the patterns from the pattern_dir\n\n        Searches for .py files inside the python file, and then tries to import them\n\n        Args:\n            pattern_dir (str): The directory to search in\n        \"\"\"\n\n        print(f\"{tcolors.OKBLUE}{print_message_centered('Loading Patterns', 60, '#')}{tcolors.ENDC}\")\n\n        pattern_files = [f for f in os.listdir(pattern_dir) if f.endswith(\".py\")]\n        patterns: dict[str, ModuleType] = {}\n        for file in pattern_files:\n            print(\"loading pattern from \" + file + \"        \", end=\"\\r\")\n            try:\n                module_name = os.path.splitext(file)[0]\n                module = __import__(\"patterns.\" + module_name)\n                pattern_module = getattr(module, module_name)\n\n                pattern_module.draw\n                name = module_name\n                print_tabulated(name, \"\", \"\", 20)\n                patterns[name] = pattern_module\n\n            except Exception as e:\n                print(f\"{tcolors.FAIL}skipping {file} | wrong configuration | {e} {tcolors.ENDC}\")\n\n        print(f\"{tcolors.OKBLUE}{print_message_centered('Loading Patterns', 60, '#')}{tcolors.ENDC}\")\n\n        attribute.Store.get_store().reset()\n        self.patterns = patterns\n\n\n    def draw_current(self):\n        \"\"\"draw_current Draw the current pattern\n\n        Takes the currently loaded pattern and runs it, if no pattern is loaded then nothing will happen\n        \"\"\"\n        if self.currentPattern != None:\n            try:\n                if self.generator:\n                    next(self.generator)\n                else:\n                    res: Generator[None, None, None] | None = self.currentPattern.draw()\n                    if isinstance(res, GeneratorType):\n                        self.generator = res\n            except Exception as e:\n                self.generator = None\n                self.currentPattern = None\n                print(\"There was an error\", e)\n\n\n    def load_pattern(self, name: str):\n        \"\"\"load_pattern Loads a pattern\n\n        Load the pattern with a given name from the patterns directory\n\n        Args:\n            name (str): _description_\n\n        Note:\n            TODO fix so people cant just inject whatever name they want from client side :skull:\n        \"\"\"\n        attribute.Store.get_store().reset()\n        module = __import__(\"patterns.\" + name)\n        pattern_module = getattr(module, name)\n        importlib.reload(pattern_module)\n        self.currentPattern = self.patterns[name]\n        self.generator = None\n        print(attribute.Store.get_store().store)\n\n    def unload_pattern(self):\n        \"\"\"unload_pattern Resets the manager state\n\n        Reset the current pattern and generator variables to effectively restart the manager\n        \"\"\"\n\n        self.currentPattern = None\n        self.generator = None\n\n    def get(self, name: str):\n        \"\"\"get Gets a pattern\n\n        Feteches the pattern with a given name from the internal pattern list, then returns it\n\n        Args:\n            name (str): The name of the pattern you want to fetch\n\n        Returns:\n            code (str): Returns the python code of the pattern\n        \"\"\"\n\n        return self.patterns[name]\n</code></pre>"},{"location":"docs/patternManager/#backend.pattern_manager.PatternManager.__init__","title":"<code>__init__(pattern_dir)</code>","text":"<p>init Initialise the pattern manager</p> <p>Create a new instance of the pattern manager and load the <code>on</code> pattern</p> <p>Parameters:</p> Name Type Description Default <code>pattern_dir</code> <code>str</code> <p>The directory to search for pattern files. The search is carried out automatically</p> required Source code in <code>backend\\pattern_manager.py</code> <pre><code>def __init__(self, pattern_dir: str):\n    \"\"\"__init__ Initialise the pattern manager\n\n    Create a new instance of the pattern manager and load the `on` pattern\n\n    Args:\n        pattern_dir (str): The directory to search for pattern files. The search is carried out automatically\n    \"\"\"\n    self.load_patterns(pattern_dir)\n\n    self.currentPattern = self.patterns[\"on\"]\n\n    self.generator = None\n</code></pre>"},{"location":"docs/patternManager/#backend.pattern_manager.PatternManager.draw_current","title":"<code>draw_current()</code>","text":"<p>draw_current Draw the current pattern</p> <p>Takes the currently loaded pattern and runs it, if no pattern is loaded then nothing will happen</p> Source code in <code>backend\\pattern_manager.py</code> <pre><code>def draw_current(self):\n    \"\"\"draw_current Draw the current pattern\n\n    Takes the currently loaded pattern and runs it, if no pattern is loaded then nothing will happen\n    \"\"\"\n    if self.currentPattern != None:\n        try:\n            if self.generator:\n                next(self.generator)\n            else:\n                res: Generator[None, None, None] | None = self.currentPattern.draw()\n                if isinstance(res, GeneratorType):\n                    self.generator = res\n        except Exception as e:\n            self.generator = None\n            self.currentPattern = None\n            print(\"There was an error\", e)\n</code></pre>"},{"location":"docs/patternManager/#backend.pattern_manager.PatternManager.get","title":"<code>get(name)</code>","text":"<p>get Gets a pattern</p> <p>Feteches the pattern with a given name from the internal pattern list, then returns it</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the pattern you want to fetch</p> required <p>Returns:</p> Name Type Description <code>code</code> <code>str</code> <p>Returns the python code of the pattern</p> Source code in <code>backend\\pattern_manager.py</code> <pre><code>def get(self, name: str):\n    \"\"\"get Gets a pattern\n\n    Feteches the pattern with a given name from the internal pattern list, then returns it\n\n    Args:\n        name (str): The name of the pattern you want to fetch\n\n    Returns:\n        code (str): Returns the python code of the pattern\n    \"\"\"\n\n    return self.patterns[name]\n</code></pre>"},{"location":"docs/patternManager/#backend.pattern_manager.PatternManager.load_pattern","title":"<code>load_pattern(name)</code>","text":"<p>load_pattern Loads a pattern</p> <p>Load the pattern with a given name from the patterns directory</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>description</p> required Note <p>TODO fix so people cant just inject whatever name they want from client side </p> Source code in <code>backend\\pattern_manager.py</code> <pre><code>def load_pattern(self, name: str):\n    \"\"\"load_pattern Loads a pattern\n\n    Load the pattern with a given name from the patterns directory\n\n    Args:\n        name (str): _description_\n\n    Note:\n        TODO fix so people cant just inject whatever name they want from client side :skull:\n    \"\"\"\n    attribute.Store.get_store().reset()\n    module = __import__(\"patterns.\" + name)\n    pattern_module = getattr(module, name)\n    importlib.reload(pattern_module)\n    self.currentPattern = self.patterns[name]\n    self.generator = None\n    print(attribute.Store.get_store().store)\n</code></pre>"},{"location":"docs/patternManager/#backend.pattern_manager.PatternManager.load_patterns","title":"<code>load_patterns(pattern_dir)</code>","text":"<p>load_patterns Loads the patterns from the pattern_dir</p> <p>Searches for .py files inside the python file, and then tries to import them</p> <p>Parameters:</p> Name Type Description Default <code>pattern_dir</code> <code>str</code> <p>The directory to search in</p> required Source code in <code>backend\\pattern_manager.py</code> <pre><code>def load_patterns(self, pattern_dir: str):\n    \"\"\"load_patterns Loads the patterns from the pattern_dir\n\n    Searches for .py files inside the python file, and then tries to import them\n\n    Args:\n        pattern_dir (str): The directory to search in\n    \"\"\"\n\n    print(f\"{tcolors.OKBLUE}{print_message_centered('Loading Patterns', 60, '#')}{tcolors.ENDC}\")\n\n    pattern_files = [f for f in os.listdir(pattern_dir) if f.endswith(\".py\")]\n    patterns: dict[str, ModuleType] = {}\n    for file in pattern_files:\n        print(\"loading pattern from \" + file + \"        \", end=\"\\r\")\n        try:\n            module_name = os.path.splitext(file)[0]\n            module = __import__(\"patterns.\" + module_name)\n            pattern_module = getattr(module, module_name)\n\n            pattern_module.draw\n            name = module_name\n            print_tabulated(name, \"\", \"\", 20)\n            patterns[name] = pattern_module\n\n        except Exception as e:\n            print(f\"{tcolors.FAIL}skipping {file} | wrong configuration | {e} {tcolors.ENDC}\")\n\n    print(f\"{tcolors.OKBLUE}{print_message_centered('Loading Patterns', 60, '#')}{tcolors.ENDC}\")\n\n    attribute.Store.get_store().reset()\n    self.patterns = patterns\n</code></pre>"},{"location":"docs/patternManager/#backend.pattern_manager.PatternManager.unload_pattern","title":"<code>unload_pattern()</code>","text":"<p>unload_pattern Resets the manager state</p> <p>Reset the current pattern and generator variables to effectively restart the manager</p> Source code in <code>backend\\pattern_manager.py</code> <pre><code>def unload_pattern(self):\n    \"\"\"unload_pattern Resets the manager state\n\n    Reset the current pattern and generator variables to effectively restart the manager\n    \"\"\"\n\n    self.currentPattern = None\n    self.generator = None\n</code></pre>"},{"location":"docs/patternManager/#backend.pattern_manager.print_message_centered","title":"<code>print_message_centered(msg, min_len, padding=' ')</code>","text":"<p>print_message_centered Print a message that is centered in the terminal</p> <p>Creates a message string that contains the message and the required padding to make it appear in the center</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message to display</p> required <code>min_len</code> <code>int</code> <p>The minimum length of the message for it to be centered</p> required <code>padding</code> <code>str</code> <p>The character to use for padding the message. Defaults to \" \".</p> <code>' '</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The padded message</p> Source code in <code>backend\\pattern_manager.py</code> <pre><code>def print_message_centered(msg: str, min_len: int, padding: str = \" \") -&gt; str:\n    \"\"\"print_message_centered Print a message that is centered in the terminal\n\n    Creates a message string that contains the message and the required padding to make it appear in the center\n\n    Args:\n        msg (str): The message to display\n        min_len (int): The minimum length of the message for it to be centered\n        padding (str, optional): The character to use for padding the message. Defaults to \" \".\n\n    Returns:\n        str: The padded message\n    \"\"\"\n    if len(msg) &gt; min_len:\n        return msg\n    msg = \" \" + msg + \" \"\n    if len(msg) &gt; min_len:\n        return msg\n    padding_needed = min_len - len(msg)\n    l_padding = math.floor(padding_needed / 2)\n    r_padding = math.ceil(padding_needed / 2)\n    return padding * l_padding + msg + padding * r_padding\n</code></pre>"},{"location":"docs/patternManager/#backend.pattern_manager.print_tabulated","title":"<code>print_tabulated(item1, item2, item3, max_length)</code>","text":"<p>print_tabulated Print a table</p> <p>Print a table of three columns wide</p> <p>Parameters:</p> Name Type Description Default <code>item1</code> <code>str</code> <p>The first column text</p> required <code>item2</code> <code>str</code> <p>The second column text</p> required <code>item3</code> <code>str</code> <p>The third column text</p> required <code>max_length</code> <code>int</code> <p>The maximum length of text allow in a column</p> required Source code in <code>backend\\pattern_manager.py</code> <pre><code>def print_tabulated(item1: str, item2: str, item3: str, max_length: int):\n    \"\"\"print_tabulated Print a table\n\n    Print a table of three columns wide\n\n    Args:\n        item1 (str): The first column text\n        item2 (str): The second column text\n        item3 (str): The third column text\n        max_length (int): The maximum length of text allow in a column\n    \"\"\"\n    # Cap the length of each item\n    item1 = item1[:max_length].ljust(max_length)\n    item2 = item2[:max_length].ljust(max_length)\n    item3 = str(item3)[:max_length].ljust(max_length)\n\n    # Print the tabulated items\n    print(f\"{tcolors.OKGREEN}{item1}{item2}{item3}{tcolors.ENDC}\")\n</code></pre>"},{"location":"docs/renderer/","title":"Renderer","text":"<p>Contains the renderer class that handles frames on the tree</p>"},{"location":"docs/renderer/#backend.renderer.Renderer","title":"<code>Renderer</code>","text":"<p>summary</p> <p>extended_summary</p> Warning <p>This module is intended for internal use only. You do not need to use any of this in your pattern code</p> Source code in <code>backend\\renderer.py</code> <pre><code>class Renderer:\n    \"\"\" _summary_\n\n    _extended_summary_\n\n    Warning:\n        This module is intended for internal use only. You do not need to use any of this in your pattern code\n    \"\"\"\n\n    def __init__(self, coords: list[tuple[float, float, float]]):\n        \"\"\"__init__ _summary_\n\n        _extended_summary_\n\n        Args:\n            coords (list[tuple[float, float, float]]): _description_\n        \"\"\"\n\n        # create a 10 frame buffer to the pixel driver\n        self.frame_queue: multiprocessing.Queue[Optional[tuple[int, list[int]]]] = multiprocessing.Queue(10)\n\n        # select the correct pixel driver for the system, either physical or sim\n        driver = self._pick_driver(len(coords))\n        self.pixel_driver = driver(self.frame_queue, coords)\n\n        self.fps = 45\n\n        process = multiprocessing.Process(target=self.pixel_driver.run, args=())\n        process.start()\n\n    def add_to_queue(self, frame: list[int]):\n        \"\"\"Add a frame to the queue to be rendered\n        This function blocks until there is space in the queue\"\"\"\n        self.frame_queue.put((self.fps, frame))\n        pass\n\n    def _pick_driver(self, num_leds: int):\n        \"\"\"_pick_driver Pick the driver for rendering\n\n        If we have pygame use that, else we can use pixel\n\n        Args:\n            num_leds (int): The number of LEDs to render\n\n        Returns:\n            ws2812_tree.ws2812_tree: Physical tree. Used if there are less than 500 LEDs\n            ws2812_tree_dual.ws2812_tree_dual: Physical tree. Used if there are more than 500 LEDs\n            sim_tree.SimTree: Simulated tree\n        \"\"\"\n\n        try:\n            if num_leds &gt; 500:\n                from pixel_driver import ws2812_tree_dual\n\n                return ws2812_tree_dual.ws2812_tree_dual\n            else:\n                from pixel_driver import ws2812_tree\n\n                return ws2812_tree.ws2812_tree\n\n        except ImportError:\n            print(f\"{tcolors.WARNING}Using pygame simulator, Neopixels not found{tcolors.ENDC}\\n\")\n\n            from pixel_driver import sim_tree\n            return sim_tree.SimTree\n</code></pre>"},{"location":"docs/renderer/#backend.renderer.Renderer.__init__","title":"<code>__init__(coords)</code>","text":"<p>init summary</p> <p>extended_summary</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>list[tuple[float, float, float]]</code> <p>description</p> required Source code in <code>backend\\renderer.py</code> <pre><code>def __init__(self, coords: list[tuple[float, float, float]]):\n    \"\"\"__init__ _summary_\n\n    _extended_summary_\n\n    Args:\n        coords (list[tuple[float, float, float]]): _description_\n    \"\"\"\n\n    # create a 10 frame buffer to the pixel driver\n    self.frame_queue: multiprocessing.Queue[Optional[tuple[int, list[int]]]] = multiprocessing.Queue(10)\n\n    # select the correct pixel driver for the system, either physical or sim\n    driver = self._pick_driver(len(coords))\n    self.pixel_driver = driver(self.frame_queue, coords)\n\n    self.fps = 45\n\n    process = multiprocessing.Process(target=self.pixel_driver.run, args=())\n    process.start()\n</code></pre>"},{"location":"docs/renderer/#backend.renderer.Renderer.add_to_queue","title":"<code>add_to_queue(frame)</code>","text":"<p>Add a frame to the queue to be rendered This function blocks until there is space in the queue</p> Source code in <code>backend\\renderer.py</code> <pre><code>def add_to_queue(self, frame: list[int]):\n    \"\"\"Add a frame to the queue to be rendered\n    This function blocks until there is space in the queue\"\"\"\n    self.frame_queue.put((self.fps, frame))\n    pass\n</code></pre>"},{"location":"docs/util/","title":"Utils","text":"<p>Holds a bunch of utility functions to make life easier</p>"},{"location":"docs/util/#backend.util.save_lights","title":"<code>save_lights(light_locs)</code>","text":"<p>save_lights Save the loaded tree lights</p> <p>Writes the locations of all lights passed into the file tree.csv</p> <p>Parameters:</p> Name Type Description Default <code>light_locs</code> <code>list[list[int]]</code> <p>The list of tree light positions</p> required Source code in <code>backend\\util.py</code> <pre><code>def save_lights(light_locs: list[list[int]]) -&gt; None:\n    \"\"\"save_lights Save the loaded tree lights\n\n    Writes the locations of all lights passed into the file tree.csv\n\n    Args:\n        light_locs (list[list[int]]): The list of tree light positions\n    \"\"\"\n    with open('tree.csv', 'w', newline='') as file:\n        writer = csv.writer(file)\n        writer.writerows(light_locs)\n</code></pre>"},{"location":"samples/","title":"Code Samples","text":"<p>Welcome to the code samples section of the GRIDmas Tree docs. Here you can find the same sample code that is in the main portal of the GRIDmas Tree web editor, except with some more detail for context.</p>"},{"location":"samples/#todo","title":"Todo","text":"<p>This list shows the tasks that Owen has yet to complete. All code for the samples is included, it is mainly descriptions that are still to be done.</p>"},{"location":"samples/#code-insertion","title":"Code Insertion","text":"<ul> <li> Fully completed</li> </ul>"},{"location":"samples/#page-details","title":"Page Details","text":"<p>Each page needs a title</p> <ul> <li> Not yet done...</li> </ul>"},{"location":"samples/#_1","title":"Code Samples","text":"<p>Each pattern should have a description of what it does so that people can quickly find the pattern they are looking for</p>"},{"location":"samples/3dFire/","title":"3D Fire","text":"<p>A 3D Fire animation by Godzil</p> <pre><code>from tree import tree\nimport math\nimport random\n\nname = \"3D Fire\"\nauthor = \"Godzil\"\n# derived from https://github.com/standupmaths/xmastree2020/blob/main/examples/3dfire.py\n\n# Play with these values to change how coarse the 3D Fire effect is.\n# Smaller value == faster\nMATWX = 10\nMATWY = 10\nMATWZ = 30\n\n# Change that value to change colour brightness.\n# May need to tweak the palette if changing that value\nmaxBrightness = 255\n\n\nclass boundingBox():\n    def __init__(self):\n        self.minX = math.inf\n        self.maxX = -math.inf\n        self.minY = math.inf\n        self.maxY = -math.inf\n        self.minZ = math.inf\n        self.maxZ = -math.inf\n        self.wX = 0\n        self.wY = 0\n        self.wZ = 0\n\n    def update(self, x, y, z):\n        if self.minX &gt; x:\n            self.minX = x\n        if self.maxX &lt; x:\n            self.maxX = x\n\n        if self.minY &gt; y:\n            self.minY = y\n        if self.maxY &lt; y:\n            self.maxY = y\n\n        if self.minZ &gt; z:\n            self.minZ = z\n        if self.maxZ &lt; z:\n            self.maxZ = z\n\n    def finalize(self):\n        self.wX = self.maxX - self.minX\n        self.wY = self.maxY - self.minY\n        self.wZ = self.maxZ - self.minZ\n\n    def normalize(self, x, y, z):\n        lx = (x - self.minX) / self.wX\n        ly = (y - self.minY) / self.wY\n        lz = (z - self.minZ) / self.wZ\n        return lx, ly, lz\n\n\nclass matrix():\n    def __init__(self, lx, ly, lz, bb):\n        self._list = [0] * lx * ly * lz\n        self._strideX = 1\n        self._strideY = self._strideX * lx\n        self._strideZ = self._strideY * ly\n        self._bb = bb\n        self._wX = lx\n        self._wY = ly\n        self._wZ = lz\n\n    def get(self, x, y, z):\n        return self._list[x * self._strideX + y * self._strideY + z * self._strideZ]\n\n    def set(self, x, y, z, val):\n        self._list[x * self._strideX + y * self._strideY + z * self._strideZ] = val\n\n    def copy(self, other):\n        self._list = other._list[:]\n\n    def getTree(self, x, y, z):\n        localX, localY, localZ = self._bb.normalize(x, y, z)\n        localX = int(localX * (self._wX - 1))\n        localY = int(localY * (self._wY - 1))\n        localZ = int(localZ * (self._wZ - 1))\n        return self.get(localX, localY, localZ)\n\n\ndef run():\n    # Color are G R B\n    palette: list[tuple[int, int, int]] = []\n\n    # Transition points\n    palBST = 70\n    palB2R = 86  # Black to Red\n    palR2Y = 99  # Red to Yellow\n\n    # Black only\n    for i in range(0, palBST):\n        palette.append((0, 0, 0))\n    # Black to red\n    for i in range(palBST, palB2R):\n        palette.append((int((i - palBST) / (palB2R - palBST) * maxBrightness), 0, 0))\n    # red to yellow\n    for i in range(palB2R, palR2Y):\n        palette.append((maxBrightness, int((i - palB2R) / (palR2Y - palB2R) * maxBrightness), 0))\n    # yellow to white\n    for i in range(palR2Y, 256):\n        palette.append((255, 255, int((i - (palR2Y)) / (256 - palR2Y) * maxBrightness)))\n\n    treeBB = boundingBox()\n    for i in tree.coords:\n        treeBB.update(i[0], i[1], i[2])\n\n    treeBB.finalize()\n\n    # Our working area. We work with a non code/cylinder shape as it\n    # would make thing too complicated\n    workMat = matrix(MATWX, MATWY, MATWZ, treeBB)\n    oldMat = matrix(MATWX, MATWY, MATWZ, treeBB)\n\n    while True:\n\n        for LED, pixel in enumerate(tree.pixels):\n            v = workMat.getTree(tree.coords[LED][0], tree.coords[LED][1], tree.coords[LED][2])\n            pixel.set_rgb(*palette[v])\n\n        tree.update()\n\n        oldMat.copy(workMat)\n\n        # Update the matrix\n        for x in range(1, MATWX - 1):\n            for y in range(1, MATWY - 1):\n                for z in range(2, MATWZ):\n                    v = oldMat.get(x, y, z - 2)\n                    v = v + oldMat.get(x - 1, y, z - 1)\n                    v = v + oldMat.get(x, y - 1, z - 1)\n                    v = v + oldMat.get(x, y, z - 1)\n                    v = v + oldMat.get(x, y + 1, z - 1)\n                    v = v + oldMat.get(x + 1, y, z - 1)\n                    v = max(min(int(v / 6), 255), 0)\n\n                    workMat.set(x, y, z, v)\n\n        # light the fire!\n        for x in range(0, MATWX):\n            for y in range(0, MATWY):\n                for z in range(0, 2):\n                    if random.uniform(0, 1) &lt; 0.35:\n                        workMat.set(x, y, z, 255)\n                    else:\n                        workMat.set(x, y, z, 0)\n</code></pre>"},{"location":"samples/3dPlasma/","title":"3D Plasma","text":"<p>A 3D Plasma animation by Godzil</p> <pre><code>from tree import tree\nimport math\n\nname = \"3D Plasma\"\nauthor = \"Godzil\"\n# derived from https://github.com/standupmaths/xmastree2020/blob/main/examples/3dplasma.py\n\n# Play with these values to change how coarse the plasma effect is.\n# Smaller value == faster\nMATWX = 10\nMATWY = 10\nMATWZ = 30\n\n# Set this value to lower the RGB (1 = full range, 0.5 = Half range, etc...)\ndimLight = 0.8\n\n\nclass boundingBox():\n    def __init__(self):\n        self.minX = math.inf\n        self.maxX = -math.inf\n        self.minY = math.inf\n        self.maxY = -math.inf\n        self.minZ = math.inf\n        self.maxZ = -math.inf\n        self.wX = 0\n        self.wY = 0\n        self.wZ = 0\n\n    def update(self, x, y, z):\n        if self.minX &gt; x:\n            self.minX = x\n        if self.maxX &lt; x:\n            self.maxX = x\n\n        if self.minY &gt; y:\n            self.minY = y\n        if self.maxY &lt; y:\n            self.maxY = y\n\n        if self.minZ &gt; z:\n            self.minZ = z\n        if self.maxZ &lt; z:\n            self.maxZ = z\n\n    def finalize(self):\n        self.wX = self.maxX - self.minX\n        self.wY = self.maxY - self.minY\n        self.wZ = self.maxZ - self.minZ\n\n    def normalize(self, x, y, z):\n        lx = (x - self.minX) / self.wX\n        ly = (y - self.minY) / self.wY\n        lz = (z - self.minZ) / self.wZ\n        return lx, ly, lz\n\n\nclass matrix():\n    def __init__(self, lx, ly, lz, bb):\n        self._list = []\n        for _ in range(lx * ly * lz):\n            self._list.append([0, 0, 0])\n\n        self._strideX = 1\n        self._strideY = self._strideX * lx\n        self._strideZ = self._strideY * ly\n        self._bb = bb\n        self._wX = lx\n        self._wY = ly\n        self._wZ = lz\n\n    def get(self, x, y, z):\n        return self._list[x * self._strideX + y * self._strideY + z * self._strideZ]\n\n    def set(self, x, y, z, val):\n        self._list[x * self._strideX + y * self._strideY + z * self._strideZ] = val\n\n    def getTree(self, x, y, z):\n        localX, localY, localZ = self._bb.normalize(x, y, z)\n        localX = int(localX * (self._wX - 1))\n        localY = int(localY * (self._wY - 1))\n        localZ = int(localZ * (self._wZ - 1))\n        return self.get(localX, localY, localZ)\n\n\ndef dist(x, y, z, wx, wy, wz):\n    return math.sqrt((x - wx) * (x - wx) + (y - wy) * (y - wy) + (z - wz) * (z - wz))\n\n\ndef run():\n\n    treeBB = boundingBox()\n    for i in tree.coords:\n        treeBB.update(i[0], i[1], i[2])\n\n    treeBB.finalize()\n\n    workMat = matrix(MATWX, MATWY, MATWZ, treeBB)\n\n    t = 0\n\n    while True:\n\n        for LED, pixel in enumerate(tree.pixels):\n            pixel.set_rgb(*map(lambda x: int(x), workMat.getTree(tree.coords[LED][0], tree.coords[LED][1], tree.coords[LED][2])))\n\n        tree.update()\n\n        # Update the matrix\n        for x in range(0, MATWX):\n            for y in range(0, MATWY):\n                for z in range(0, MATWZ):\n                    d1 = dist(x + t, y, z, MATWX, MATWY, MATWZ)\n                    d2 = dist(x, y, z, MATWX / 2, MATWY / 2, MATWZ)\n                    d3 = dist(x, y + t / 7, z, MATWX * 0.75, MATWY / 2, MATWZ)\n                    d4 = dist(x, y, z, MATWX * 0.75, MATWY, MATWZ)\n\n                    value = math.sin(d1 / 8) + math.sin(d2 / 8.0) + math.sin(d3 / 7.0) + math.sin(d4 / 8.0)\n\n                    colour = int((4 + value)) * 32\n                    r = min(colour, 255) * dimLight\n                    g = min(colour * 2, 255) * dimLight\n                    b = min(255 - colour, 255) * dimLight\n\n                    workMat.set(x, y, z, (g, r, b))\n        t = t + 1\n</code></pre>"},{"location":"samples/badApple/","title":"Bad Apple","text":"<p>A demonstration of how to load a video file and play it on the tree by Ciaran</p> <pre><code>from tree import tree\nimport cv2\n\nname = \"Bad Apple\"\nauthor = \"Ciaran\"\n\n\ndef run():\n    cap = cv2.VideoCapture(\"patterns/badapple.mp4\")\n    coords = []\n\n    for pixel in tree.pixels:\n        videox = max(min(int(((-pixel.x + 1) / 2) * 480), 479), 0)\n        videoy = max(min(int((1 - pixel.z / 2) * 360), 359), 0)\n        coords.append((videox, videoy))\n\n    tree.set_fps(30)\n\n    while True:\n\n        ret, frame = cap.read()\n        if not ret:\n            break\n\n        for i, pixel in enumerate(tree.pixels):\n            if 0.5 &lt; pixel.z &lt; 2.5:\n                value = int(frame[coords[i][1]][coords[i][0]][0])\n                pixel.set_rgb(value, value, value)\n\n            else:\n                pixel.set_rgb(0, 0, 0)\n        tree.update()\n\n    cap.release()\n</code></pre>"},{"location":"samples/borealis/","title":"Borealis","text":"<p>An animation of an aurora borealis made by Claude V3.5</p> <pre><code>import math\nimport random\nfrom attribute import RangeAttr, ColorAttr\nfrom tree import tree\nfrom colors import Color\n\nname = \"Aurora Borealis\"\nauthor = \"Claude 3.5\"\n\n\ndef interpolate_color(color1, color2, factor):\n    return Color(\n        int(color1.r + (color2.r - color1.r) * factor),\n        int(color1.g + (color2.g - color1.g) * factor),\n        int(color1.b + (color2.b - color1.b) * factor)\n    )\n\n\ndef run():\n    flow_speed = RangeAttr(\"Flow Speed\", 0.02, 0.01, 0.1, 0.01)\n    color_shift_speed = RangeAttr(\"Color Shift Speed\", 0.01, 0.001, 0.05, 0.001)\n    wave_frequency = RangeAttr(\"Wave Frequency\", 1.5, 0.5, 3.0, 0.1)\n    sparkle_chance = RangeAttr(\"Sparkle Chance\", 0.0005, 0.0001, 0.01, 0.0001)\n\n    color1 = ColorAttr(\"Color 1\", Color(0, 255, 100))  # Green\n    color2 = ColorAttr(\"Color 2\", Color(100, 200, 255))  # Light blue\n    color3 = ColorAttr(\"Color 3\", Color(255, 100, 200))  # Pink\n\n    time = 0\n    while True:\n        for i, pixel in enumerate(tree.pixels):\n            # Calculate the base wave using the pixel's x and y coordinates\n            wave = math.sin(wave_frequency.get() * (pixel.x + pixel.y) + time)\n\n            # Add vertical movement\n            wave += math.sin(wave_frequency.get() * 0.5 * pixel.z + time * 1.5)\n\n            # Normalize the wave to [0, 1]\n            wave = (wave + 2) / 4\n\n            # Calculate color based on the wave and time\n            if wave &lt; 0.33:\n                factor = wave * 3\n                color = interpolate_color(color1.get(), color2.get(), factor)\n            elif wave &lt; 0.67:\n                factor = (wave - 0.33) * 3\n                color = interpolate_color(color2.get(), color3.get(), factor)\n            else:\n                factor = (wave - 0.67) * 3\n                color = interpolate_color(color3.get(), color1.get(), factor)\n\n            # Add occasional sparkle\n            if random.random() &lt; sparkle_chance.get():\n                color = Color(255, 255, 255)  # White sparkle\n\n            tree.set_light(i, color)\n\n        tree.update()\n        time += flow_speed.get()\n\n        # Slowly shift the colors over time\n        hue_shift = color_shift_speed.get()\n        color1.set(Color.from_hsl((time * hue_shift) % 1, 1, 0.5))\n        color2.set(Color.from_hsl(((time * hue_shift) + 0.33) % 1, 1, 0.6))\n        color3.set(Color.from_hsl(((time * hue_shift) + 0.67) % 1, 1, 0.7))\n</code></pre>"},{"location":"samples/caduceus/","title":"Caduceus","text":"<p>A caduceus demonstration made by Ciaran</p> <pre><code>import random\nimport math\nfrom particle_system import ParticleSystem, SphereParticle\nfrom tree import tree\nfrom colors import Color\n\nname = \"Caduceus\"\nauthor = \"Ciaran\"\n\nradius = 0.15\n\n\nclass Snake(SphereParticle):\n    def __init__(self):\n        super().__init__(0, 0, -radius, radius, 200, Color.random())\n        self.angle = random.random() * 2 * math.pi\n        self.dist = random.randint(2, 7) / 10\n        self.pitch = random.randint(15, 25) / 100\n        self.speed = random.randint(3, 10) / 100\n\n    def advance(self):\n        self.z += self.speed\n        dist = self.dist * ((self.z / - tree.height) + 1)\n        self.angle += self.pitch\n        self.x = dist * math.sin(self.angle)\n        self.y = dist * math.cos(self.angle)\n\n        if (self.z &gt; tree.height + radius):\n            self.is_dead = True\n\n\ndef run():\n    particle_system = ParticleSystem(tree)\n\n    while True:\n        for _ in range(random.randint(5, 20)):\n\n            tree.fade()\n\n            particle_system.draw()\n            particle_system.advance()\n\n        particle_system.add_particle(Snake())\n</code></pre>"},{"location":"samples/centerFinder/","title":"Center Finder","text":"<p>A demonstration of finding the center of the tree by Ciaran</p> <pre><code>from attribute import RangeAttr\n\nfrom tree import tree\n\nname = \"Center Finder\"\nauthor = \"Ciaran\"\n\n\ndef run():\n    portion = RangeAttr(\"position\", 0, -1, 1, 0.01)\n    while True:\n        for pixel in tree.pixels:\n            if pixel.y &gt; portion.get():\n                pixel.set_rgb(200, 0, 0)\n            else:\n                pixel.set_rgb(0, 0, 200)\n        tree.update()\n</code></pre>"},{"location":"samples/checkers/","title":"Checkers","text":"<p>Creates a checkerboard pattern on the tree. By Ciaran</p> <pre><code>from tree import tree\nfrom colors import Color\n\nname = \"Checkers\"\nauthor = \"Ciaran\"\n\n\ndef run():\n\n    while True:\n        color1 = Color.random()\n        color2 = Color.different_from(color1)\n        for pixel in tree.pixels:\n            x = 0\n            if pixel.x % 2 &gt; 1:\n                x ^= 1\n            if pixel.y % 2 &gt; 1:\n                x ^= 1\n            if pixel.z % 2 &gt; 1:\n                x ^= 1\n            if x == 0:\n                pixel.set_color(color1)\n            else:\n                pixel.set_color(color2)\n        tree.update()\n        tree.sleep(45)\n</code></pre>"},{"location":"samples/chemplanes/","title":"Chem Planes","text":"<p>By Ciaran</p> <pre><code>import random\nfrom attribute import RangeAttr\nfrom colors import Color\nfrom animations.wipe import wipe_frames\n\n\nname = \"Chem planes\"\nauthor = \"Ciaran\"\n\n\ndef run():\n    color = Color(255, 255, 0)\n    speed = RangeAttr(\"speed\", 45, 30, 90, 1)\n    while True:\n        theta = random.uniform(0, 6.28)\n        alpha = random.uniform(0, 6.28)\n        wipe_frames(theta, alpha, color, int(speed.get()), Color.black())\n        color = Color.different_from(color)\n</code></pre>"},{"location":"samples/colorSwitcher/","title":"Color Switcher","text":"<p>By Murtaza</p> <pre><code>from attribute import ColorAttr\nfrom colors import Color\nfrom tree import tree\n\nname = \"Color Switcher\"\nauthor = \"Murtaza\"\nnum_colors = 2\n\ndef run():\n    tree.set_fps(1)\n    colors = [Color.random() for i in range(num_colors)]\n    while True:\n        for pixel_index, pixel in enumerate(tree.pixels):\n            for color_index, color in enumerate(colors):\n                if pixel_index % num_colors == color_index:\n                    pixel.set_color(color)\n        tree.update()\n        colors = [Color.different_from(color) for color in colors]\n</code></pre>"},{"location":"samples/fireWork/","title":"Fireworks","text":"<p>By Ciaran</p> <pre><code>import random\nfrom colors import Color\nfrom util import euclidean_distance\nfrom tree import tree\n\nname = \"Fire Works\"\nauthor = \"Ciaran\"\n\n\nclass Explosion():\n    def __init__(self, x, y, z, max_age):\n        self.x = x\n        self.y = y\n        self.z = z\n        self.max_age = max_age\n        self.tick = 0\n        self.color = Color.random()\n\n\ndef run():\n    explosions: list[Explosion] = []\n    i = 0\n    interval = 50\n    while True:\n        if i == 0:\n            randomid = random.randrange(0, tree.num_pixels - 1)\n            center_light = tree.get_light(randomid)\n            explosions.append(Explosion(center_light.x, center_light.y, center_light.z, 5))\n            interval = random.randrange(50, 140)\n        i = (i + 1) % interval\n\n        for exp in explosions:\n            exp.tick += 1\n\n        for pixel in tree.pixels:\n            a = random.random()\n            if a &gt; 0.8:\n                pixel.fade(random.randrange(100, 120, 1) / 100)\n            elif a &gt; 0.77:\n                pixel.set_color(Color.black())\n            elif a &gt; 0.765:\n                pixel.fade(0.5)\n\n            for exp in explosions:\n                if exp.tick / 6 &lt; euclidean_distance([exp.x, exp.y, exp.z], [pixel.x, pixel.y, pixel.z]) &lt; exp.tick / 5:\n                    pixel.set_color(exp.color)\n\n        tree.update()\n        explosions = list(filter(lambda x: x.tick &lt;= x.max_age, explosions))\n</code></pre>"},{"location":"samples/fountain/","title":"Fountain","text":"<p>By Ciaran</p> <pre><code>from tree import tree\nimport math\nimport random\nfrom particle_system import ParticleSystem, SphereParticle\nfrom colors import Color\n\n\nname = \"Fountain\"\nauthor = \"Ciaran\"\n\n\nclass Dropplet(SphereParticle):\n    def __init__(self):\n        super().__init__(0, 0, 0, 0.15, 100, Color(100, 100, 240))\n        self.zAcl = -0.003\n        self.zVel = 0.1\n        self.xVel = 0.008\n        self.dist = 0\n        self.angle = random.random() * 2 * math.pi\n\n    def advance(self):\n        self.z += self.zVel\n        self.zVel += self.zAcl\n\n        self.x = self.dist * math.sin(self.angle)\n        self.y = self.dist * math.cos(self.angle)\n\n        self.dist += self.xVel\n\n        if (self.z &lt; -0.2):\n            self.is_dead = True\n\n\ndef run():\n    particle_system = ParticleSystem(tree)\n    while True:\n\n        for _ in range(random.randint(2, 3)):\n\n            tree.fade()\n\n            particle_system.draw()\n            particle_system.advance()\n        particle_system.add_particle(Dropplet())\n\n\nif __name__ == \"__main__\":\n    run()\n</code></pre>"},{"location":"samples/harderStronger/","title":"Harder Better Faster Stronger","text":"<p>By Ciaran</p> <pre><code>from tree import tree\nfrom colors import Color\n\nname = \"Harder Better Faster Stronger\"\nauthor = \"Ciaran\"\n\n\ndef run():\n    # each second is 40 frames, the song is 123 bpm which is 41 fps\n    tree.set_fps(41)\n    tree.sleep(50)\n\n    # count in, 4 white flashes then press play on red\n    for _ in range(4):\n        tree.fill(Color.white())\n        tree.sleep(5)\n        tree.fill(Color.black())\n        tree.sleep(15)\n\n    tree.fill(Color.red())\n    tree.sleep(5)\n    tree.fill(Color.black())\n    tree.sleep(15)\n\n    # 8 beat intro thing\n    tree.sleep(4 * 40 + 20)\n\n    for _ in range(8):\n        tree.fill(Color.white())\n        tree.sleep(5)\n        tree.fill(Color.black())\n        tree.sleep(15)\n\n    for _ in range(8):\n        tree.fill(Color.red())\n        tree.sleep(10)\n        tree.fill(Color.green())\n        tree.sleep(10)\n\n\n    for _ in range(8):\n        tree.fill(Color.white())\n        tree.sleep(5)\n        tree.fill(Color.black())\n        tree.sleep(15)\n\n    for _ in range(6):\n        tree.fill(Color.red())\n        tree.sleep(10)\n        tree.fill(Color.green())\n        tree.sleep(10)\n\n    tree.fill(Color.black())\n    for pixel in tree.pixels:\n        if pixel.x &lt; 0:\n            pixel.set_color(Color.white())\n    tree.sleep(10)\n\n    tree.fill(Color.black())\n    for pixel in tree.pixels:\n        if pixel.x &gt; 0:\n            pixel.set_color(Color.white())\n    tree.sleep(10)\n\n    tree.fill(Color.black())\n    for pixel in tree.pixels:\n        if pixel.z &lt; tree.height / 2:\n            pixel.set_color(Color.white())\n    tree.sleep(10)\n\n    tree.fill(Color.black())\n    for pixel in tree.pixels:\n        if pixel.z &gt; tree.height / 2:\n            pixel.set_color(Color.white())\n    tree.sleep(10)\n</code></pre>"},{"location":"samples/helixSpin/","title":"Helix Spin","text":"<p>A spinning helix demonstration By chatGPT</p> <pre><code>import time\nimport math\nfrom attribute import RangeAttr\nfrom tree import tree\nfrom colors import Color\n\nname = \"Helix Spin\"\nauthor = \"chatGPT\"\n\n# Constants for the HelixSpin pattern\nASCENT_SPEED = 0.01  # Speed of movement upwards\nCOLOR_CYCLE_SPEED = 0.05  # Speed of color change\n\n\ndef run():\n    angle_offset = 0  # Current angle offset for spinning\n    vertical_offset = 0  # Current vertical offset for moving upwards\n\n    HELIX_STRANDS = RangeAttr(\"helix strands\", 1, 0, 4, 1)  # Number of strands in the helix\n    SPIN_SPEED = RangeAttr(\"spin speed\", 0.08, 0.06, 0.24, 0.01)  # Speed of spinning around the tree\n    twist = RangeAttr(\"Twist\", 6, 1, 20, 0.5)\n\n    while True:\n        # Each frame, calculate the color based on a simple cycling pattern\n        r = int((math.sin(COLOR_CYCLE_SPEED * time.time()) + 1) / 2 * 255)\n        g = int((math.sin(COLOR_CYCLE_SPEED * time.time() + 2 * math.pi / 3) + 1) / 2 * 255)\n        b = int((math.sin(COLOR_CYCLE_SPEED * time.time() + 4 * math.pi / 3) + 1) / 2 * 255)\n\n        for pixel in tree.pixels:\n\n            # Calculate the angle of this point around the center of the tree\n            angle = math.atan2(pixel.y, pixel.x)\n            # Determine the strand by position along the z-axis and the number of strands\n            strand = int((HELIX_STRANDS.get() * (pixel.z / tree.height + vertical_offset)) % HELIX_STRANDS.get())\n\n            # Check if the light is close to the helix for this strand\n            if abs((angle - angle_offset - 2 * math.pi * strand / HELIX_STRANDS.get() + pixel.z * twist.get()) % (2 * math.pi) &lt; 0.2 or (angle - angle_offset - 2 * math.pi * strand / HELIX_STRANDS.get() + pixel.z * twist.get()) % (2 * math.pi) &gt; 2 * math.pi - 0.2):\n                # Set the color for lights close to the helix part\n                pixel.set_color(Color(r, g, b))\n            else:\n                # Dim other lights\n                pixel.fade(1.1)\n\n        # Update the tree display\n        tree.update()\n\n        # Move the helix\n        angle_offset = (angle_offset + SPIN_SPEED.get()) % (2 * math.pi)\n        vertical_offset = (vertical_offset + ASCENT_SPEED) % 1\n</code></pre>"},{"location":"samples/hueRotate/","title":"Rotating Hues","text":"<p>By Ciaran</p> <pre><code>from tree import tree\nfrom colors import Color\nfrom attribute import RangeAttr\n\nname = \"Hue Rotate\"\nauthor = \"Ciaran\"\n\n\ndef run():\n    hue = 0\n    speed = RangeAttr(\"speed\", 0.003, -0.005, 0.005, 0.0001)\n    while True:\n        hue = (hue + speed.get()) % 1\n        for pixel in tree.pixels:\n            pixel.set_color(Color.from_hsl(hue, 1, 0.5))\n        tree.update()\n</code></pre>"},{"location":"samples/jumpyBalls/","title":"Jumping Balls","text":"<p>By Ciaran</p> <pre><code>from particle_system import ParticleSystem, SphereParticle\nimport random\nfrom colors import Color\nfrom tree import tree\n\n\nname = \"Jumpy Balls\"\nauthor = \"Ciaran\"\n\nclass Ball(SphereParticle):\n    def __init__(self):\n\n        super().__init__(random.random() - 0.5, random.random()-0.5, tree.height, 0.2, 100, Color.random())\n        self.xVel = (random.random() - 0.5) * 0.3\n        self.yVel = (random.random() - 0.5) * 0.3\n        self.zVel = (1 - random.random()) * 0.03\n\n    def advance(self):\n        self.zVel -= 0.03\n        self.z += self.zVel\n        self.x += self.xVel\n        self.y += self.yVel\n\n        if self.z &lt; 0:\n            self.zVel *= -0.9\n            self.z = 0.1\n        if self.x &gt; 0.8 or self.x &lt; -0.8:\n            self.xVel *= -0.9\n            self.yVel += (random.random() - 0.5) * 0.1\n        if self.y &gt; 0.8 or self.y &lt; -0.8:\n            self.yVel *= -0.9\n            self.xVel += (random.random() - 0.5) * 0.1\n\n\n\n\ndef run():\n\n    particle_system = ParticleSystem(tree)\n\n\n    while True:\n        particle_system.add_particle(Ball())\n        for _ in range(random.randrange(50, 100)):\n            tree.lerp(Color(0, 0, 0), 5)\n            particle_system.draw()\n            particle_system.advance()\n            tree.update()\n</code></pre>"},{"location":"samples/lerpy/","title":"Lerpy","text":"<p>By Ciaran</p> <pre><code>from util import ease_in_out_expo\nfrom colors import Color\nfrom tree import tree\n\nname = \"Lerpy\"\nauthor = \"Ciaran\"\n\n\ndef run():\n    color = Color.random()\n    while True:\n        for pixel in tree.pixels:\n            pixel.lerp(color.to_tuple(), 50, fn=ease_in_out_expo)\n\n        tree.sleep(100, allow_lerp=True)\n\n        color = Color.different_from(color)\n</code></pre>"},{"location":"samples/murca/","title":"Murca","text":"<p>Red, White, and of course Blue</p> <p>By Ciaran</p> <pre><code>import random\nfrom tree import tree\n\nname = \"murca\"\nauthor = \"Ciaran\"\n\n\ndef run():\n    y = 0\n\n    stars = [random.randint(0, tree.num_pixels) for _ in range(100)]\n\n    while True:\n        y = (y + 0.01) % tree.height\n        for pixel in tree.pixels:\n            if ((pixel.z + y) % tree.height * 2 &gt;= tree.height):\n                # do stars\n                pixel.set_rgb(0, 0, 255)\n\n        for star in stars:\n            tree.pixels[star].set_rgb(200, 200, 200)\n\n        for pixel in tree.pixels:\n            if not ((pixel.z + y) % tree.height * 2 &gt;= tree.height):\n                if (pixel.x % 0.6) &gt; 0.3:\n                    pixel.set_rgb(255, 0, 0)\n                else:\n                    pixel.set_rgb(200, 200, 200)\n        tree.update()\n</code></pre>"},{"location":"samples/off/","title":"Off","text":"<p>By Ciaran</p> <pre><code>from animations import fizzle\nfrom tree import tree\nname = \"Off\"\nauthor = \"Ciaran\"\n\n\ndef run():\n    fizzle.fizzle()\n\n    tree.set_fps(1)\n</code></pre>"},{"location":"samples/on/","title":"On","text":"<p>This example is a basic pattern that loops through every pixel on the tree and sets them all to the <code>on</code> state</p> on.py<pre><code>from prelude import *\n\ni = 0\ndef draw(): # (1)!\n    global i\n    for pixel in tree.pixels:\n        if pixel.z &lt; i:\n            pixel.set_rgb(200, 55, 2)\n\n    i += tree.height / 70\n</code></pre> <ol> <li>You might notice the difference in patterns this year.     Your pattern now does not have control over the tree directly. You must have a <code>draw()</code> function to make your pattern run</li> </ol>"},{"location":"samples/planes/","title":"Planes","text":"<p>By Ciaran</p> <pre><code>import random\nfrom attribute import RangeAttr\nfrom colors import Color\nfrom animations.wipe import wipe_frames\n\n\nname = \"Planes\"\nauthor = \"Ciaran\"\n# based on Matt Parkers Xmas tree\n\n\ndef run():\n    color = Color(255, 255, 0)\n    speed = RangeAttr(\"speed\", 45, 30, 45, 1)\n    while True:\n        theta = random.uniform(0, 6.28)\n        alpha = random.uniform(0, 6.28)\n        wipe_frames(theta, alpha, color, int(speed.get()))\n        color = Color.different_from(color)\n</code></pre>"},{"location":"samples/rgb/","title":"RGB","text":"<p>By Ciaran</p> <pre><code>from attribute import RangeAttr\nfrom tree import tree\nimport time\n\nname = \"RGB\"\nauthor = \"Ciaran\"\n\n\ndef run():\n    sleep_time = RangeAttr(\"sleep time\", 1, 0.1, 3, 0.1)\n\n    offset = 0\n    while True:\n        offset = (offset + 1) % 3\n\n        for i, pixel in enumerate(tree.pixels):\n            r = 255 if (i + offset) % 3 == 0 else 0\n            g = 255 if (i + offset) % 3 == 1 else 0\n            b = 255 if (i + offset) % 3 == 2 else 0\n            pixel.set_rgb(r, g, b)\n        tree.update()\n        time.sleep(sleep_time.get())\n</code></pre>"},{"location":"samples/rgbHelix/","title":"RGB Helix","text":"<p>By Ciaran</p> <pre><code>import math\nfrom attribute import RangeAttr\n\nfrom tree import tree\nfrom colors import Color\nimport random\n\nname = \"RGB Helix\"\nauthor = \"Ciaran\"\n\n\ndef run():\n    twist_dx = RangeAttr(\"twist speed\", 0.01, 0.001, 0.2, 0.001)\n    rotate_amount = RangeAttr(\"Rotate speed\", 0.01, 0.001, 0.1, 0.001)\n    twist_dir = 1\n    twist_amount = -random.randrange(-8, 8)\n    speed = 2\n    offset = random.random() * math.pi * 2\n    color_offset = random.random()\n    while True:\n        for pixel in tree.pixels:\n\n            modified_angle = (pixel.a + pixel.z * twist_amount + offset * speed) % (math.pi * 2)\n\n            a = round((modified_angle) / math.pi)\n\n            hue = a / 2\n            pixel.set_color(Color.from_hsl((hue + color_offset) % 1, 1, 0.5))\n\n        tree.update()\n\n        offset = (offset + rotate_amount.get()) % (math.pi * 2)\n\n        color_offset = (0.00027 + color_offset) % 1\n\n        twist_amount += twist_dir * twist_dx.get()\n        if twist_amount &gt; 10:\n            twist_dir = -1\n        elif twist_amount &lt; -10:\n            twist_dir = 1\n</code></pre>"},{"location":"samples/rgbSpheres/","title":"RGB Spheres","text":"<p>By NeunEinser</p> <pre><code>import math\nfrom tree import tree\nfrom colors import Color\nimport random\n\nname = \"RGB spheres\"\nauthor = \"NeunEinser\"\n# Derived from https://github.com/standupmaths/xmastree2020/blob/main/examples/rgb-spheres.py\n\n\ndef vdist(v1: list, v2: list):\n    if len(v1) != len(v2):\n        return -1\n\n    result = 0\n    for i in range(len(v1)):\n        result += (v1[i] - v2[i]) ** 2\n    return math.sqrt(result)\n\n\n# Find coordinate that maximizes the distance for a given sez of other coords\ndef find_furthest(points: list, coords):\n    max_dist = 0\n    cur_pnt = points[0]\n    for coord in coords:\n        dist = math.inf\n        for p in points:\n            p_dist = vdist(p, coord)\n            if p_dist &lt; dist:\n                dist = p_dist\n\n        if (dist &gt; max_dist):\n            max_dist = dist\n            cur_pnt = coord\n    return cur_pnt\n\n\ndef run():\n    # init sphere origins.\n    # First sphere's origin is furthest from the coordinate system's origin\n    # Second sphere's origin is the LED with the greatest distance from the first sphere's origin\n    # Third sphere's origin is the LED where the distance for both other spheres is maximized.\n    sphere_origins = []\n    sphere_origins.append(find_furthest([[0, 0, 0]], tree.coords))\n    sphere_origins.append(find_furthest(sphere_origins, tree.coords))\n    sphere_origins.append(find_furthest(sphere_origins, tree.coords))\n\n    # calculate maximum distance of any LED for each sphere's origin.\n    # Used to determine the max radius each sphere will ever receive\n    max_dists = [0., 0., 0.]\n    for coord in tree.coords:\n        for i in range(3):\n            dist = vdist(coord, sphere_origins[i])\n            if max_dists[i] &lt; dist:\n                max_dists[i] = dist\n\n    # The rate in which each sphere enlargens. When negative, the sphere is currently shrinking.\n    increment_rates = [0., 0., 0.]\n    # The radius of each sphere. Initial value is randomized\n    radii = [0., 0., 0.]\n\n    # set initial increment rates and radii\n    for i in range(3):\n        # Frames per cycle for current sphere\n        frames = i * 40 + 120\n        increment_rates[i] = max_dists[i] / frames\n\n        # Random start radius\n        radii[i] = random.random() * frames * increment_rates[i]\n\n    # infinitly many frames. Wohoo.\n    while True:\n        for i in range(tree.num_pixels):\n\n            # calculate color for current pixel. Each rgb (grb) color value is 255 * dist / max_dist\n            color = [0, 0, 0]\n            for s in range(3):\n                dist = abs(vdist(sphere_origins[s], tree.coords[i]) - radii[s])\n                color[s] = int(255 * (1 - dist / max_dists[s]) ** 3)\n            tree.set_light(i, Color(*color))\n\n        tree.update()\n\n        # calculate radii for next iteration.\n        for s in range(3):\n            # Switch from enlarging to shrinking and vice versa, as needed\n            new_radius = radii[s] + increment_rates[s]\n            if new_radius &gt;= max_dists[s]:\n                increment_rates[s] = -abs(increment_rates[s])\n            elif new_radius &lt;= 0:\n                increment_rates[s] = abs(increment_rates[s])\n\n            radii[s] += increment_rates[s]\n</code></pre>"},{"location":"samples/ripplingWaves/","title":"Rippling Waves","text":"<p>By Claude V3.5</p> <pre><code>import math\nfrom attribute import RangeAttr, ColorAttr\nfrom tree import tree\nfrom colors import Color\n\nname = \"Rippling Waves\"\nauthor = \"Claude 3.5\"\n\n\ndef run():\n    wave_speed = RangeAttr(\"Wave Speed\", 0.1, 0.01, 0.5, 0.01)\n    wave_frequency = RangeAttr(\"Wave Frequency\", 2.0, 0.5, 5.0, 0.1)\n    color_speed = RangeAttr(\"Color Speed\", 0.02, 0.01, 0.1, 0.01)\n    primary_color = ColorAttr(\"Primary Color\", Color(255, 0, 0))\n    secondary_color = ColorAttr(\"Secondary Color\", Color(0, 0, 255))\n\n    time = 0\n    while True:\n        for i, pixel in enumerate(tree.pixels):\n            # Calculate the wave based on height (z-coordinate) and time\n            wave = math.sin(wave_frequency.get() * (pixel.z / tree.height * 2 * math.pi + time))\n\n            # Map the wave to a value between 0 and 1\n            wave_mapped = (wave + 1) / 2\n\n            # Interpolate between primary and secondary colors\n            r = int(primary_color.get().r * wave_mapped + secondary_color.get().r * (1 - wave_mapped))\n            g = int(primary_color.get().g * wave_mapped + secondary_color.get().g * (1 - wave_mapped))\n            b = int(primary_color.get().b * wave_mapped + secondary_color.get().b * (1 - wave_mapped))\n\n            # Add a radial component based on distance from the center\n            distance = math.sqrt(pixel.x**2 + pixel.y**2)\n            radial_factor = (math.sin(distance * wave_frequency.get() * 2 + time) + 1) / 2\n\n            # Combine the vertical wave with the radial component\n            combined_factor = (wave_mapped + radial_factor) / 2\n\n            # Set the final color\n            tree.set_light(i, Color(\n                int(r * combined_factor),\n                int(g * combined_factor),\n                int(b * combined_factor)\n            ))\n\n        tree.update()\n        time += wave_speed.get()\n\n        # Slowly shift the primary and secondary colors\n        hue_shift = color_speed.get()\n        primary_color.set(Color.from_hsl((time * hue_shift) % 1, 1, 0.5))\n        secondary_color.set(Color.from_hsl(((time * hue_shift) + 0.5) % 1, 1, 0.5))\n</code></pre>"},{"location":"samples/snowing/","title":"Snowing","text":"<p>By Ciaran</p> <pre><code>from tree import tree\nimport random\nfrom particle_system import ParticleSystem, SphereParticle\nfrom colors import Color\n\n\nname = \"Snowing\"\nauthor = \"Ciaran\"\n\n\nclass SnowFlake(SphereParticle):\n    def __init__(self, x, y):\n        super().__init__(x, y, tree.height + 0.2, 0.2, 100, Color(200, 200, 240))\n        self.yVel = 0.05\n\n    def advance(self):\n        self.z -= self.yVel\n        self.yVel += 0.002\n\n        if (self.z &lt; -0.2):\n            self.is_dead = True\n\n\ndef run():\n    particle_system = ParticleSystem(tree)\n\n    while True:\n        for _ in range(random.randint(5, 30)):\n\n            tree.fade()\n\n            particle_system.draw()\n            particle_system.advance()\n\n        particle_system.add_particle(SnowFlake(random.random() - 0.5, random.random() - 0.5))\n</code></pre>"},{"location":"samples/solidColor/","title":"Solid Color","text":"<p>By Ciaran</p> <pre><code>from attribute import ColorAttr\nfrom colors import Color\nfrom tree import tree\n\nname = \"Solid Color\"\nauthor = \"Ciaran\"\n\n\ndef run():\n    col = ColorAttr(\"Color\", Color(200, 20, 0))\n    tree.set_fps(45)\n    while True:\n        for pixel in tree.pixels:\n            pixel.set_color(col.get())\n        tree.update()\n</code></pre>"},{"location":"samples/sphereFill/","title":"Sphere Fill","text":"<p>By Ciaran</p> <pre><code>from particle_system import ParticleSystem, SphereParticle\nfrom tree import tree\nfrom colors import Color\n\nname = \"Sphere Fill\"\nauthor = \"Ciaran\"\n\n\nclass Sphere(SphereParticle):\n    def __init__(self):\n        super().__init__(0, 0, tree.height / 2, 0, 300, Color.random())\n\n    def advance(self):\n        self.radius += 0.01\n\n\ndef run():\n    particle_system = ParticleSystem(tree)\n    particle_system.add_particle(Sphere())\n\n    tree.black()\n    while True:\n        for _ in range(100):\n\n            particle_system.fast_draw()\n            particle_system.advance()\n        particle_system.add_particle(Sphere(), start=True)\n\n\nif __name__ == \"__main__\":\n    run()\n</code></pre>"},{"location":"samples/spin/","title":"Spin","text":"<p>By Ciaran</p> <pre><code>import math\nfrom colors import Color\nfrom attribute import RangeAttr, ColorAttr\n\nfrom tree import tree\n\nname = \"Spin\"\nauthor = \"Ciaran\"\n# based on Matt Parkers xmas tree\n\n\ndef run():\n    speed = RangeAttr(\"speed\", 0.02, -0.1, 0.1, 0.001)\n    color1 = ColorAttr(\"color 1\", Color(0, 50, 50))\n    color2 = ColorAttr(\"color 2\", Color(50, 50, 0))\n\n    heights: list[float] = []\n    for i in tree.coords:\n        heights.append(i[2])\n\n    angle = 0\n\n    # the starting point on the vertical axis\n    c = -tree.height / 2\n    while True:\n\n        for pixel in tree.pixels:\n            # figure out if the pixel is above or below the plane\n            if (math.tan(angle) * pixel.x &lt;= pixel.z + c) ^ (angle &gt; 0.5 * math.pi) ^ (angle &gt;= 1.5 * math.pi):\n                pixel.set_color(color1.get())\n            else:\n                pixel.set_color(color2.get())\n\n        # use the show() option as rarely as possible as it takes ages\n        # do not use show() each time you change a LED but rather wait until you have changed them all\n        tree.update()\n\n        # now we get ready for the next cycle\n\n        angle = (angle + speed.get()) % (2 * math.pi)\n</code></pre>"},{"location":"samples/starryNight/","title":"Starry Night","text":"<p>By Claude V3.5</p> <pre><code>import random\nimport math\nfrom attribute import RangeAttr, ColorAttr\nfrom tree import tree\nfrom colors import Color\n\nname = \"Starry Night\"\nauthor = \"Claude 3.5\"\n\n\nclass Star:\n    def __init__(self, index, brightness):\n        self.index = index\n        self.brightness = brightness\n        self.twinkle_speed = random.uniform(0.02, 0.1)\n        self.twinkle_offset = random.uniform(0, 2 * math.pi)\n\n\nclass ShootingStar:\n    def __init__(self, start_index, direction, speed):\n        self.current_index = start_index\n        self.direction = direction\n        self.speed = speed\n        self.life = 1.0\n\n\ndef run():\n    star_density = RangeAttr(\"Star Density\", 0.1, 0.05, 0.3, 0.01)\n    shooting_star_chance = RangeAttr(\"Shooting Star Chance\", 0.01, 0.001, 0.05, 0.001)\n\n    background_color = Color(0, 0, 0)  # Dark blue night sky\n    star_color = ColorAttr(\"Star Color\", Color(255, 255, 200))  # Warm white\n\n    stars = []\n    shooting_stars = []\n    time = 0\n\n    # Initialize stars\n    for i in range(tree.num_pixels):\n        if random.random() &lt; star_density.get():\n            stars.append(Star(i, random.uniform(0.1, 1.0)))\n\n    while True:\n        # Clear the tree\n        for i in range(tree.num_pixels):\n            tree.set_light(i, background_color)\n\n        # Update and draw stars\n        for star in stars:\n            brightness = star.brightness * (0.5 + 0.5 * math.sin(time * star.twinkle_speed + star.twinkle_offset))\n            color = Color(\n                int(star_color.get().r * brightness),\n                int(star_color.get().g * brightness),\n                int(star_color.get().b * brightness)\n            )\n            tree.set_light(star.index, color)\n\n        # Update and draw shooting stars\n        for shooting_star in shooting_stars:\n            color = Color(\n                int(star_color.get().r * shooting_star.life),\n                int(star_color.get().g * shooting_star.life),\n                int(star_color.get().b * shooting_star.life)\n            )\n            tree.set_light(int(shooting_star.current_index % tree.num_pixels), color)\n\n            # Move the shooting star\n            shooting_star.current_index += shooting_star.speed * shooting_star.direction\n            shooting_star.life -= 0.05\n\n        # Remove dead shooting stars\n        shooting_stars = [ss for ss in shooting_stars if ss.life &gt; 0]\n\n        # Chance to add a new shooting star\n        if random.random() &lt; shooting_star_chance.get():\n            start_index = random.randint(0, tree.num_pixels - 1)\n            direction = 1 if random.random() &lt; 0.5 else -1\n            speed = random.uniform(0.5, 2.0)\n            shooting_stars.append(ShootingStar(start_index, direction, speed))\n\n        tree.update()\n        time += 0.1\n\n        # Occasionally add or remove stars\n        if random.random() &lt; 0.01:\n            if random.random() &lt; 0.5 and len(stars) &gt; 0:\n                stars.pop(random.randint(0, len(stars) - 1))\n            elif len(stars) &lt; tree.num_pixels * star_density.get():\n                new_index = random.randint(0, tree.num_pixels - 1)\n                if new_index not in [star.index for star in stars]:\n                    stars.append(Star(new_index, random.uniform(0.1, 1.0)))\n</code></pre>"},{"location":"samples/strip/","title":"Strip","text":"<p>By Ciaran</p> <pre><code>from tree import tree\nfrom colors import Color\nfrom attribute import RangeAttr, ColorAttr\n\nname = \"Strip\"\nauthor = \"Ciaran\"\n\n\ndef run():\n    tree.fps = 75\n    fade = RangeAttr(\"fade\", 1.1, 1.01, 2, 0.01)\n    color = ColorAttr(\"Color\", Color.white())\n    while True:\n        for pixel in tree.pixels:\n            pixel.set_color(color.get())\n\n            for pixel in tree.pixels:\n                pixel.fade(n=fade.get())\n\n            tree.update()\n</code></pre>"},{"location":"samples/text/","title":"Text","text":"<p>'dya like jazz?</p> <p>By Ciaran</p> <pre><code>import cv2\nfrom tree import tree\nimport numpy as np\n\nname = \"Text\"\nauthor = \"Ciaran\"\n\n\ndef run():\n    height = tree.height\n    a = -500\n\n    coords = []\n    text = \"(Black screen with text; The sound of buzzing bees can be heard)According to all known laws of aviation, : there is no way a bee should be able to fly. : Its wings are too small to get its fat little body off the ground. : The bee, of course, flies anyway : because bees don't care what humans think is impossible.\"\n    scale = 100\n\n    for pixel in tree.pixels:\n        videox = max(min(int((pixel.x + 1) * scale), scale * 2 - 1), 0)\n        videoy = max(min(int((tree.height - pixel.z) * scale), int(scale * tree.height - 1)), 0)\n        coords.append((videox, videoy))\n\n    font = cv2.FONT_HERSHEY_SIMPLEX  # Font type\n    font_scale = int(height * scale * 0.03)  # Font scale (size)\n    font_color = (0, 0, 0)  # Black color in BGR\n    thickness = int(height * scale * 0.1)  # Thickness of the text\n\n    while True:\n        a += 5\n        blank_image = np.ones((int(scale * height), int(scale * 2), 3), dtype=np.uint8)\n\n\n\n        # Calculate the center of the image to place the text\n        text_size = cv2.getTextSize(text, font, font_scale, thickness)[0]\n\n        cv2.putText(blank_image, text, (-a, int(scale * height * 0.8)), font, font_scale, (255, 255, 255), thickness, cv2.LINE_AA)\n        \"\"\"\n        cv2.imshow('Image with Text', blank_image)\n        cv2.waitKey(0)\n        cv2.destroyAllWindows()\n        \"\"\"\n\n        for i, pixel in enumerate(tree.pixels):\n            value = int(blank_image[coords[i][1]][coords[i][0]][0])\n            pixel.set_rgb(value, value, value)\n        tree.update()\n\nif __name__ == \"__main__\":\n    run()\n</code></pre>"},{"location":"samples/twinkle/","title":"Twinkle","text":"<p>By Ciaran</p> <pre><code>from tree import tree\nimport random\nfrom colors import Color\nfrom attribute import ColorAttr\n\nname = \"Twinkle\"\nauthor = \"Ciaran\"\n\n\ndef run():\n    baseColor = ColorAttr(\"color\", Color(120, 20, 0))\n    while True:\n        tr, tg, tb = baseColor.get().to_tuple()\n        x = random.randint(0, tree.num_pixels - 1)\n\n        tree.set_light(x, Color.black())\n\n        for pixel in tree.pixels:\n            r, g, b = pixel.to_tuple()\n            pixel.set_rgb(min(int(r + 5), tr), min(int(g + 5), tg), min(int(b + 5), tb))\n\n        tree.update()\n</code></pre>"},{"location":"samples/twinklingStarts/","title":"Twinkling Stars","text":"<p>By chatGPT</p> <pre><code>import random\nfrom tree import tree\nfrom colors import Color\n\nname = \"Twinkling Stars\"\nauthor = \"chatGPT\"\n\n\ndef run():\n    star_color = Color(255, 255, 255)  # Star color - white\n    sky_color = Color(15, 15, 40)  # Dark \"sky\" color - deep blue\n    twinkling_frequency = 0.1  # Chance of a light twinkling each second\n\n    # First, color the entire tree in dark sky color\n    for pixel in tree.pixels:\n        pixel.set_color(sky_color)\n\n    # Update the tree initially\n    tree.update()\n\n    while True:\n        for pixel in tree.pixels:\n            if random.random() &lt; twinkling_frequency:\n                if random.random() &gt; 0.5:\n                    pixel.set_color(star_color)\n                else:\n                    pixel.set_color(sky_color)\n\n        # Update the tree display\n        tree.update()\n</code></pre>"},{"location":"samples/wanderingBall/","title":"Wandering Ball","text":"<p>By Ciaran</p> <pre><code>import random\nimport math\n\nfrom tree import tree\nfrom colors import Color\nfrom attribute import ColorAttr, RangeAttr\n\nname = \"Wandering Ball\"\nauthor = \"Ciaran\"\n\n\ndef run():\n    height = 0.5\n    angle = random.randrange(0, 627) / 100\n    angle2 = random.randrange(0, 627) / 100\n\n    dist = 0.3\n    radius = RangeAttr(\"radius\", 0.4, 0.1, 0.8, 0.03)\n    color = ColorAttr(\"ball color\", Color.white())\n    trailLength = RangeAttr(\"Trail Length\", 100, 5, 200, 5)\n    while True:\n\n        center = [dist * math.sin(angle), dist * math.cos(angle), height]\n        height = abs(math.sin(angle2)) * (tree.height - radius.get() * 2) + radius.get()\n        for pixel in tree.pixels:\n            distance_to_center: float = math.sqrt((pixel.x - center[0]) ** 2 + (pixel.y - center[1]) ** 2 + (pixel.z - center[2]) ** 2)\n\n            # Check if the current LED is within the expanding sphere\n            if distance_to_center &lt;= radius.get():\n                pixel.set_color(color.get())\n            else:\n                pixel.lerp((0, 0, 0), int(trailLength.get()))\n\n        angle = (angle + 0.1) % 6.28\n        angle2 = (angle2 + 0.034) % 6.28\n\n        tree.update()\n</code></pre>"},{"location":"samples/waveFlow/","title":"Wave Flow","text":"<p>By Ciaran</p> <pre><code>from prelude import *\nimport time\nimport math\n\nwave_offset = 0  # this will move the wave up along the z-axis (height)\ndef draw():\n    global wave_offset\n    wave_speed = 0.03\n    wave_period = 0.5\n    color_change_rate = 0.2\n\n    # slowly change color over time for the wave (rainbow-like cycle)\n    r = int((math.sin(color_change_rate * time.time()) + 1) / 2 * 255)\n    g = int((math.sin(color_change_rate * time.time() + 2 * math.pi / 3) + 1) / 2 * 255)\n    b = int((math.sin(color_change_rate * time.time() + 4 * math.pi / 3) + 1) / 2 * 255)\n    wave_color = (r, g, b)\n\n    for pixel in tree.pixels:\n        # a basic 3d wave function based on the z-coordinate and a changing 'wave_offset'\n        intensity = 0.5 * (math.cos(2 * math.pi * (pixel.z / tree.height + wave_offset) / wave_period) + 1)\n        # using intensity to modify the brightness of the color\n        wave_intensity_color = Color(int(wave_color[0] * intensity), int(wave_color[1] * intensity), int(wave_color[2] * intensity))\n\n        # set the light to the calculated color\n        pixel.set_color(wave_intensity_color)\n\n        # increase the wave offset to move the wave upwards\n    wave_offset = (wave_offset + wave_speed) % (6)\n</code></pre>"},{"location":"samples/waves/","title":"Waves","text":"<p>By Ciaran</p> <pre><code>import random\nfrom animations.wipe import wipe_wave_frames\nfrom attribute import RangeAttr\nfrom colors import Color\n\n\nname = \"Waves\"\nauthor = \"Ciaran\"\n\n\ndef run():\n    speed = RangeAttr(\"Speed\", 45, 30, 90, 1)\n    length = RangeAttr(\"Length\", 45, 30, 90, 1)\n    color = Color.random()\n    while True:\n        theta = random.uniform(0, 6.28)\n        alpha = random.uniform(0, 6.28)\n        wipe_wave_frames(theta, alpha, color, int(speed.get()), int(length.get()))\n        color = Color.different_from(color)\n</code></pre>"},{"location":"samples/xyzPlanes/","title":"XYZ Planes","text":"<p>By Ciaran</p> <pre><code>from colors import Color\nimport math\nfrom animations.wipe import wipe\nfrom attribute import RangeAttr\n\nname = \"XYZ Planes\"\nauthor = \"Ciaran\"\n\n\ndef run():\n\n    dirs = [(0, 0), (math.pi / 2, math.pi / 2), (math.pi / 2, 0)]\n\n    color = Color.random()\n    speed = RangeAttr(\"speed\", 10, 1, 14, 1)\n    while True:\n        for dir in dirs:\n            color = Color.different_from(color)\n            wipe(dir[0], dir[1], color, int(speed.get()), Color.black())\n</code></pre>"},{"location":"samples/xyzPlanes2/","title":"XYZ Planes 2","text":"<p>Electric Boogaloo</p> <p>By Ciaran</p> <pre><code>from colors import Color\nimport math\nfrom animations.wipe import wipe_frames\nfrom attribute import RangeAttr\n\nname = \"XYZ Planes2\"\nauthor = \"Ciaran\"\n\n\ndef run():\n\n    dirs = [(0, 0), (math.pi / 2, 0), (math.pi / 2, math.pi / 2), (math.pi / 2, math.pi), (math.pi / 2, math.pi * 1.5), (math.pi, 0)]\n\n    color = Color.random()\n    speed = RangeAttr(\"speed\", 45, 30, 60, 1)\n    while True:\n        for dir in dirs:\n            color = Color.different_from(color)\n            wipe_frames(dir[0], dir[1], color, int(speed.get()), Color.black())\n</code></pre>"}]}