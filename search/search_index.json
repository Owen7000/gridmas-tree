{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#gridmas-tree","title":"GRIDmas Tree","text":"<p>The GRIDmas Tree is a fully programmable christmas tree with 1000 RGB LEDs. Each LED has a 3D coordinate and can be individually addressed which allows you to create patterns or animations which run in 3D space.</p> <p>The GRIDmas Tree was originally based on Standup Maths' 500 LED christmas tree. Watch his video here. This project builds upon this foundation with a fully featured API and web-editor to allow for easy modification and testing of patterns.</p> <p></p> <p>The GRIDmas tree was created by Ciaran Cook in 2023 as a personal project, and in 2024 started a competition at Heriot Watt University. This year, there is a new API for the tree. You will find everything you need in this documentation site to make great patterns. Documentation for the project has been a joint effort between Cairan and Owen.</p> <p></p>"},{"location":"#docs","title":"Docs","text":"<p>This is the home for documentation for GRIDmas Tree 2025. Please see the table below for the different sections you can go to.</p> <ul> <li> Color for looks</li> <li> Attributes for pattern settings</li> <li> Utils for making life endurable</li> <li> Examples for example patterns</li> </ul>"},{"location":"GRIDmas24/","title":"GRIDmas 2024 \u2014 Results &amp; Highlights","text":"<p>Thank you to everyone who took part in the GRIDmas programming challenge! Supported by Heriot-Watt Robotics Society, Heriot-Watt Makers Society, and the Heriot-Watt MACS department.</p>"},{"location":"GRIDmas24/#1st-place-3d-vector-cube","title":"1st Place \u2014 3D Vector Cube","text":"<p>A beautifully rendered rotating cube in 3D space. This entry made seriously clever use of vector math and spatial transforms to produce a stable and very clean visual animation. I've been told there are even secret messages hidden in the pattern for you to decipher.</p> <p>Entry: View the code / project \u2192 </p> <p>Preview: </p>"},{"location":"GRIDmas24/#2nd-place-pick-apples","title":"2nd Place \u2014 Pick Apples","text":"<p>A wholesome interactive sequence that told the story of apples being picked from the top of the tree and carefully placed at the bottom. Charming, creative, and technically sound!</p> <p>Entry: View the code / project \u2192</p> <p>Preview: </p>"},{"location":"GRIDmas24/#3rd-place-christmas-helix","title":"3rd Place \u2014 Christmas Helix","text":"<p>A festive DNA-like helix spiralling upward through the tree. Smooth timing, great use of space, and very very Christmas-core.</p> <p>Entry: View the code / project \u2192</p> <p>Preview: </p>"},{"location":"GRIDmas24/#live-display-highlights","title":"Live Display Highlights","text":"<p>Here are some shots from the live tree during the showcase event:</p>"},{"location":"competition/","title":"GRIDmas Tree Pattern Compeititon","text":""},{"location":"competition/#the-task","title":"The Task","text":"<p>Make the best light display, making use of the 3D aspect of the tree. Patterns or animations will only be displayed for 2 minutes, but looping or procedural animations are encouraged. Patterns will be judged at our final light display, and scored by a panel of judged.</p>"},{"location":"competition/#prizes","title":"Prizes","text":"<p>Prizes have been gaciously donated by Heriot-Watt MACS department.</p> <ul> <li> <p>Technical award - \u00a350 - Use of advanced tecniques and pushes the hardware</p> </li> <li> <p>3D Award - \u00a350 - Fully ustilises 3D aspect of the tree</p> </li> <li> <p>Christmassy Award - \u00a350 - The most festive pattern</p> </li> <li> <p>Meme Award - Mystery Prize </p> </li> </ul>"},{"location":"competition/#how-to-participate","title":"How to participate","text":"<p>By sending the url of your final pattern to the microsoft form.  The form can be accessed Here</p> <p>You can also join the GRIDmas-tree discord to chat with everyone and recieve updates.</p> <p>By signing in to the website I'll also send out updates over the associated email.</p>"},{"location":"docs/","title":"User Documentation","text":"<p>This is the main hub for anyone taking part in the 2025 GRIDmas Tree project. </p> <p>Please Note</p> <p>The closing date for pattern submissions for the 2025 competition is: 14/12/2025 Please make sure you have submitted your pattern before this date</p> <p>For your first pattern, you can use this code Taken From This Example: Example - On<pre><code>from gridmas import *\n\ni = 0\ndef draw():\n    global i\n    for pixel in pixels():\n        if pixel.z &lt; i:\n            pixel.set_rgb(200, 55, 2)\n\n    i += height() / 70\n</code></pre></p> <p>From here you can build your own pattern. </p>"},{"location":"docs/#pattern-requirements","title":"Pattern Requirements","text":"<p>For a pattern to be valid, it must do have at miminum, these two lines of code:</p> <ol> <li><code>from gridmas import *</code> - This imports all the important things from the Gridmas module. Allowing you to manipulate the tree</li> <li><code>def draw(): pass</code> - Obviously replacing <code>pass</code> with the code you want to use to make the tree do things. This method is how your pattern is run by the pattern manager. </li> </ol> <p>Warning</p> <p>If you took part in the competition last year, please not that the way your pattern is run has changed. Your pattern no longer has control over the tree. The tree has control over your pattern.</p> <p>An example of this is shown below. It is the simplest pattern, it simply turns on all LEDs on the tree to a random color.</p> <pre><code>from gridmas import *\nfrom random import randint\n\ndef draw():\n    # For every frame, loop through each pixel on the tree\n    for pixel in pixels():\n        # Set each pixel to a different RGB color\n        pixel.set_rgb(randint(0, 255), randint(0, 255), randint(0, 255))\n</code></pre>"},{"location":"docs/#draw-function","title":"Draw function","text":"<p>The rendering pipeline has been heavily optimised to allow for complex patterns with lots of shapes.</p> <p>The standard frame rate is 45fps (~22ms) which is a balance between the limitations of the Raspberry pi and looking smooth on the tree. To achieve this your pattern file's <code>draw()</code> function is called ever 22ms.</p> <pre><code>def draw()\n    print(\"I'm being called every 22ms\")\n</code></pre> <p>Once the draw() function finishes, the tree is drawn to automatically. However this causes some complications, variables must be declared as global to persist between calls</p> <pre><code>a = 0\ndef draw():\n    global a\n    a += 1\n    # function is finished, draw the tree now\n</code></pre> <p>Alternatively you can use the yield syntax. Yielding pauses the execution of your pattern and allows gridmas to draw the tree. <pre><code>def draw():\n    a = 0\n    while True:\n        a += 1\n        yield # I draw the tree every 22ms\n</code></pre></p> <p>Note</p> <p>you can use the <code>yield from</code> syntax to allow yielding from other functions, this must be bubbled down to the draw function</p>"},{"location":"docs/#rendering-pipeline","title":"Rendering pipeline","text":"<p>The renderer follows a simple checklist for every pixel to decide its color:</p> <ol> <li>has the pixel been directly set. <code>pixel(n).set_color(Color.red())</code></li> <li>Do any of the shapes contain this pixel. <code>Sphere(...)</code> or <code>Line(...)</code></li> <li>Is there a background color. <code>background(Color.red())</code></li> <li>Leave the pixel the same as the last frame</li> </ol> <p>This means Shapes are drawn on top of the background, and directly setting colors is drawn on top of shapes. </p> <p>Within each layer a function can be called several times, ie. setting the same pixel to several different colors will take the last color:</p> <pre><code>background(Color.black())\ndef draw():\n    background(Color.red())\n    pixels(0).set_color(Color.red())\n    pixels(0).set_color(Color.blue())\n    pixels(0).set_color(Color.green())\n\n# draws a green pixel and the rest red\n</code></pre>"},{"location":"docs/Coordinate%20System/","title":"Coordinate System","text":"<p>GRIDmas Tree Coordinate System</p> <p>GRIDmas Tree uses GIFT for it's coordinate system. That is, Geographical Information For Trees. For a full in-depth explanation, find Matt Parkers video on his tree Here</p>"},{"location":"docs/Coordinate%20System/#how-does-gift-work","title":"How does G.I.F.T work?","text":"<p>The GIFT system starts at -1 and ends at 1 in the <code>x</code> and <code>y</code> axes. In the Z axis it goes from 0 to a maximum number. The axes are as follows:</p> <ul> <li><code>x</code>: The axis that goes towards the camera when the tree loads</li> <li><code>y</code>: The axis that goes from left, to right when the camera loads</li> <li><code>z</code>: The up/down axis.</li> </ul> <p>The origin of the tree (position 0,0,0) is set to be the centre of the trunk. This means that when the editor loads, any <code>-y</code> values will be LEDs on the left hand side of the tree, and any <code>+y</code> values will be LEDs on the right hand side. Similarly, any <code>-x</code> values will be further away from the view, and any <code>+x</code> values will be closer.</p>"},{"location":"docs/attributes/","title":"Attributes","text":"<p>Attributes allow you to change parameters of your pattern while the pattern is running from the web interface, this helps create more dynamic and customizable patterns</p> <p>Attributes should be initiallised before/outside of the draw() function</p>"},{"location":"docs/attributes/#backend.attribute.Attribute","title":"<code>Attribute(name, value)</code>","text":"<p>               Bases: <code>Generic[T]</code>, <code>ABC</code></p> <p>Only initialise attributes once in the run function</p> <p>This class should not be instantiated, it is a base class</p>"},{"location":"docs/attributes/#backend.attribute.Attribute.get","title":"<code>get()</code>","text":"<p>Get the current value of the attribute</p> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The value of the attribute</p>"},{"location":"docs/attributes/#backend.attribute.Attribute.set","title":"<code>set(value)</code>","text":"<p>Set the value of the range.</p> <p>The use of this is discouraged in a pattern, it is primarily an internal function</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The value to set the attribute to</p> required"},{"location":"docs/attributes/#backend.attribute.RangeAttr","title":"<code>RangeAttr(name, value, min, max, step)</code>","text":"<p>               Bases: <code>Attribute[float]</code></p> <p>Used when you want to accept a value from a pre defined range</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name displayed on the interface</p> required <code>value</code> <code>float</code> <p>The default starting value</p> required <code>min</code> <code>float</code> <p>The minimum value accepted</p> required <code>max</code> <code>float</code> <p>The maximum value accepted</p> required <code>step</code> <code>float</code> <p>The resolution for the range</p> required Example <pre><code>speed = RangeAttr(\"speed\", 0.2, -1, 1, 0.2)\ndef draw()\n    print(speed.get())\n</code></pre>"},{"location":"docs/attributes/#backend.attribute.ColorAttr","title":"<code>ColorAttr(name, value)</code>","text":"<p>               Bases: <code>Attribute[Color]</code></p> <p>Used when you want to accept a color as an input</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name displayed on the interface</p> required <code>value</code> <code>Color</code> <p>The initial color</p> required Example <pre><code>color1 = ColorAttr(\"color1\", Color.red())\ndef draw()\n    fill(color1.get())\n</code></pre>"},{"location":"docs/colors/","title":"Colors","text":"<p>Colors is a module which contains class definitions for Color and Pixel as well as  helper functions for converting colors between formats</p> <p>I appologise to all british programmers who spell color as colour, but within the programming world we spell it color. This will be the cause of 90% of your bugs if you're not used to programming with the color spelling</p>"},{"location":"docs/colors/#backend.colors.Color","title":"<code>Color(r, g, b)</code>","text":"<p>A class representing a color</p>"},{"location":"docs/colors/#backend.colors.Color.r","title":"<code>r</code>  <code>property</code>","text":"<p>Red component 0-255</p>"},{"location":"docs/colors/#backend.colors.Color.g","title":"<code>g</code>  <code>property</code>","text":"<p>Green component 0-255</p>"},{"location":"docs/colors/#backend.colors.Color.b","title":"<code>b</code>  <code>property</code>","text":"<p>Blue component 0-255</p> example <pre><code>myColor = Color(255, 100, 120)\nprint(myColor.r) # 255\nprint(myColor.g) # 100\nprint(myColor.b) # 120\n</code></pre>"},{"location":"docs/colors/#backend.colors.Color.rgb","title":"<code>rgb(r, g, b)</code>  <code>staticmethod</code>","text":"<p>An alias for the constructor, values between 0 and 255</p> example <pre><code>red = Color.rgb(255, 0, 0)\nblue = Color.rgb(0, 255, 0)\ngreen = Color.rgb(0, 0, 255)\n</code></pre>"},{"location":"docs/colors/#backend.colors.Color.hsl","title":"<code>hsl(hue, sat, lig)</code>  <code>staticmethod</code>","text":"<p>Get a color from hsl format, values between 0 and 1.0</p>"},{"location":"docs/colors/#backend.colors.Color.hex","title":"<code>hex(s)</code>  <code>staticmethod</code>","text":"<p>Get a color from a string hex code, in format \"#FFFFFF\"</p>"},{"location":"docs/colors/#backend.colors.Color.bit_string","title":"<code>bit_string(i)</code>  <code>staticmethod</code>","text":"<p>conver the 24bit encoded int to tuple of R, G, and B. int bitmap encoded as GGGGGGGGRRRRRRRRBBBBBBBB</p>"},{"location":"docs/colors/#backend.colors.Color.random","title":"<code>random(saturation=1, lightness=0.6)</code>  <code>staticmethod</code>","text":"<p>Generate a random color. The random value is for the Hue. The saturation and lightness can be specified</p>"},{"location":"docs/colors/#backend.colors.Color.different_from","title":"<code>different_from(color)</code>  <code>staticmethod</code>","text":"<p>Generate a random color which is different from the color passed into it, maintaining the same hue and saturation</p>"},{"location":"docs/colors/#backend.colors.Color.black","title":"<code>black()</code>  <code>staticmethod</code>","text":"<p>The color black / off</p>"},{"location":"docs/colors/#backend.colors.Color.red","title":"<code>red()</code>  <code>staticmethod</code>","text":"<p>The color red</p>"},{"location":"docs/colors/#backend.colors.Color.orange","title":"<code>orange()</code>  <code>staticmethod</code>","text":"<p>The color orange</p>"},{"location":"docs/colors/#backend.colors.Color.amber","title":"<code>amber()</code>  <code>staticmethod</code>","text":"<p>The color amber</p>"},{"location":"docs/colors/#backend.colors.Color.yellow","title":"<code>yellow()</code>  <code>staticmethod</code>","text":"<p>The color yellow</p>"},{"location":"docs/colors/#backend.colors.Color.lime","title":"<code>lime()</code>  <code>staticmethod</code>","text":"<p>The color lime</p>"},{"location":"docs/colors/#backend.colors.Color.green","title":"<code>green()</code>  <code>staticmethod</code>","text":"<p>The color green</p>"},{"location":"docs/colors/#backend.colors.Color.emerald","title":"<code>emerald()</code>  <code>staticmethod</code>","text":"<p>The color emeral</p>"},{"location":"docs/colors/#backend.colors.Color.teal","title":"<code>teal()</code>  <code>staticmethod</code>","text":"<p>The color teal</p>"},{"location":"docs/colors/#backend.colors.Color.cyan","title":"<code>cyan()</code>  <code>staticmethod</code>","text":"<p>The color cyan</p>"},{"location":"docs/colors/#backend.colors.Color.sky","title":"<code>sky()</code>  <code>staticmethod</code>","text":"<p>The color sky</p>"},{"location":"docs/colors/#backend.colors.Color.blue","title":"<code>blue()</code>  <code>staticmethod</code>","text":"<p>The color blue</p>"},{"location":"docs/colors/#backend.colors.Color.indigo","title":"<code>indigo()</code>  <code>staticmethod</code>","text":"<p>The color indigo</p>"},{"location":"docs/colors/#backend.colors.Color.violet","title":"<code>violet()</code>  <code>staticmethod</code>","text":"<p>The color violet</p>"},{"location":"docs/colors/#backend.colors.Color.purple","title":"<code>purple()</code>  <code>staticmethod</code>","text":"<p>The color purple</p>"},{"location":"docs/colors/#backend.colors.Color.fuchsia","title":"<code>fuchsia()</code>  <code>staticmethod</code>","text":"<p>The color fuchia</p>"},{"location":"docs/colors/#backend.colors.Color.pink","title":"<code>pink()</code>  <code>staticmethod</code>","text":"<p>The color pink</p>"},{"location":"docs/colors/#backend.colors.Color.rose","title":"<code>rose()</code>  <code>staticmethod</code>","text":"<p>The color rose</p>"},{"location":"docs/colors/#backend.colors.Color.white","title":"<code>white()</code>  <code>staticmethod</code>","text":"<p>The color white</p>"},{"location":"docs/colors/#backend.colors.Color.mix","title":"<code>mix(a, b, x)</code>  <code>staticmethod</code>","text":"<p>Mix two colors together</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>Color</code> <p>The first color</p> required <code>b</code> <code>Color</code> <p>The second color</p> required <code>x</code> <code>float</code> <p>the amount to mix by, 0.5 is average, 0 gives a, 1 gives b</p> required"},{"location":"docs/colors/#backend.colors.Color.to_tuple","title":"<code>to_tuple()</code>","text":"<p>Returns the tuple of the R, G and B, values between 0 and 255</p>"},{"location":"docs/colors/#backend.colors.Color.to_hex","title":"<code>to_hex()</code>","text":"<p>to_hex Get the hex value of the current color</p> <p>Convert the current color to the hex value representing it and then return</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The current color in the format #RRGGBB</p>"},{"location":"docs/colors/#backend.colors.Color.to_hsl","title":"<code>to_hsl()</code>","text":"<p>Returns the HSL values of the color, between 0 and 1.0\"</p>"},{"location":"docs/colors/#backend.colors.Color.to_bit_string","title":"<code>to_bit_string()</code>","text":"<p>Return the color as an byte string integer,  int bitmap encoded as GGGGGGGGRRRRRRRRBBBBBBBB</p>"},{"location":"docs/colors/#backend.colors.Color.on","title":"<code>on()</code>","text":"<p>on Set the color to on</p> <p>Sets the color to the fully on state (white, RGB(255,255,255))</p> <p>Examples:</p> <pre><code>my_color = Color.red() # Creates a new color that is red\nmy_color.on() # The color is now white (255,255,255)\n</code></pre>"},{"location":"docs/colors/#backend.colors.Color.off","title":"<code>off()</code>","text":"<p>off Set the color to off</p> <p>Sets the color to the fully off state (black, RGB(0,0,0))</p> <p>Examples:</p> <pre><code>my_color = Color.red() # Creates a new color that is red\nmy_color.off() # The color is now black (0,0,0)\n</code></pre>"},{"location":"docs/colors/#backend.colors.Color.fade","title":"<code>fade(n=1.1)</code>","text":"<p>fade Fades a color</p> <p>Fade the color slightly n</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>float</code> <p>Controls the speed of the fade. The larger the number, the faster it will fade. Values less than 1 cause the color to get brighter to a max color of white. Defaults to 1.1.</p> <code>1.1</code>"},{"location":"docs/colors/#backend.colors.Color.lerp","title":"<code>lerp(target, n, override=False, fn=linear)</code>","text":"<p>Linearly interpolate the color from its current color to the target color over n frames.</p> <p>Each successive call to lerp will advance the interpolation by a frame. After n amount of calls, it will be the target color. Any change to the target or frames amount will reset the interpolation from the current color. fn provides a way to choose an interpolation method, defaults to linear</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; my_color = Color.red() # (255, 0, 0)\n&gt;&gt;&gt; my_color.lerp((0, 0, 0), 5) # (205, 0, 0)\n&gt;&gt;&gt; my_color.lerp((0, 0, 0), 5) # (153, 0, 0)\n&gt;&gt;&gt; my_color.lerp((0, 0, 0), 5) # (102, 0, 0)\n&gt;&gt;&gt; my_color.lerp((0, 0, 0), 5) # (51, 0, 0)\n&gt;&gt;&gt; my_color.lerp((0, 0, 0), 5) # (0, 0, 0)\n# once reacing the target, lerp has no effect\n&gt;&gt;&gt; my_color.lerp((0, 0, 0), 5) # (0, 0, 0)\n</code></pre>"},{"location":"docs/colors/#backend.colors.Color.lerp_reset","title":"<code>lerp_reset()</code>","text":"<p>lerp_reset Reset to lerp step 0</p> <p>This method sets the previous lerp state to the current color, and sets the step number to 0</p>"},{"location":"docs/colors/#backend.colors.Color.set_lerp","title":"<code>set_lerp(target, time, override=False, fn=linear)</code>","text":"<p>This resets the lerp and starts interpolation to target from current value. Successive calls will not change the target unless override is set to True. Use with cont_lerp to have the same effect as lerp()</p>"},{"location":"docs/colors/#backend.colors.Color.cont_lerp","title":"<code>cont_lerp()</code>","text":"<p>Advanced the lerp one step.</p>"},{"location":"docs/colors/#backend.colors.Color.set","title":"<code>set(c)</code>","text":"<p>Set the color to another color by value</p>"},{"location":"docs/colors/#backend.colors.Color.set_rgb","title":"<code>set_rgb(r, g, b)</code>","text":"<p>Set the red, green and blue values of the color, values between 0 and 255</p>"},{"location":"docs/colors/#backend.colors.Color.set_hsl","title":"<code>set_hsl(hue, sat, lig)</code>","text":"<p>Set the color via HSL, values between 0 and 1.0</p>"},{"location":"docs/colors/#backend.colors.Color.set_hex","title":"<code>set_hex(s)</code>","text":"<p>Set the color with a string hex code, in format \"#FFFFFF\"</p>"},{"location":"docs/colors/#backend.colors.Color.set_bit_string","title":"<code>set_bit_string(i)</code>","text":"<p>Set the color with a string hex code, in format \"#FFFFFF\"</p>"},{"location":"docs/colors/#backend.colors.Color.set_random","title":"<code>set_random(saturation=1, lightness=0.6)</code>","text":"<p>Set the color to a random color. The random value is for the Hue. The saturation and lightness can be specified</p>"},{"location":"docs/colors/#backend.colors.Color.set_different_from","title":"<code>set_different_from(color)</code>","text":"<p>Set the color to a random color which is different from the color passed into it, maintaining the same hue and saturation</p>"},{"location":"docs/colors/#backend.colors.Color.set_different_from_self","title":"<code>set_different_from_self()</code>","text":"<p>Set the color to a random color which is different to the current color, maintaining the same hue and saturation</p>"},{"location":"docs/colors/#backend.colors.Pixel","title":"<code>Pixel(id, coord, tree, color=Color.black())</code>","text":"<p>               Bases: <code>Color</code></p> <p>The pixel class extends the Color class by adding 3D coordinates to a color. All the same methods and attributes exist on a pixel so they act the same way</p> <p>Coordintates are in the GIFT format so range between -1 and 1 on X and Y axis, and 0 and tree.height on the Z axis</p> <p>Attributes: x: float: The x axis position y: float: The y axis position z: float: The z axis position a: float: The polar angle in radians from the x axis going clockwise when looking downward on the tree d: float: The polar distance from the Z axis (trunk)</p>"},{"location":"docs/colors/#backend.colors.Pixel.id","title":"<code>id</code>  <code>property</code>","text":"<p>The id in the LED sequence</p>"},{"location":"docs/colors/#backend.colors.Pixel.x","title":"<code>x</code>  <code>property</code>","text":"<p>The X coordinate, left (-1) to right (+1)</p>"},{"location":"docs/colors/#backend.colors.Pixel.y","title":"<code>y</code>  <code>property</code>","text":"<p>The Y coordinate, front (+1) to back (-1)</p>"},{"location":"docs/colors/#backend.colors.Pixel.z","title":"<code>z</code>  <code>property</code>","text":"<p>The Z coordinate bottom (0) to top (height())</p>"},{"location":"docs/colors/#backend.colors.Pixel.xyz","title":"<code>xyz</code>  <code>property</code>","text":"<p>The tuple containing the xyz coordinates</p>"},{"location":"docs/colors/#backend.colors.Pixel.a","title":"<code>a</code>  <code>property</code>","text":"<p>The angle clockwise from the x+ direction around the tree</p>"},{"location":"docs/colors/#backend.colors.Pixel.d","title":"<code>d</code>  <code>property</code>","text":"<p>The distance from the center line (trunk) of the tree</p>"},{"location":"docs/colors/#backend.colors.Pixel.distance_to","title":"<code>distance_to(p)</code>","text":"<p>Find the distance to the passed pixel example:     ```     my_pixel = pixels(0)     print(my_pixel.distance_to(pixels(10))) # 0.45</p>"},{"location":"docs/colors/#backend.colors.Pixel.nearest","title":"<code>nearest(n)</code>","text":"<p>Find the nearest n pixels from the current</p> example <pre><code>my_pixel = pixels(0)\nneighbors = my_pixel.nearest(4)\nlen(neighbors) # 4, nearest pixels\n</code></pre>"},{"location":"docs/colors/#backend.colors.Pixel.within","title":"<code>within(d)</code>","text":"<p>Find all pixels that are within a certain radius</p> example <pre><code>my_pixel = pixels(0)\nneighbors = my_pixel.within(0.4) # pixels within 0.4 radius\n</code></pre>"},{"location":"docs/colors/#backend.colors.int2tuple","title":"<code>int2tuple(c)</code>","text":"<p>conver the 24bit encoded int to tuple of R, G, and B. int bitmap encoded as GGGGGGGGRRRRRRRRBBBBBBBB</p>"},{"location":"docs/colors/#backend.colors.tuple2int","title":"<code>tuple2int(t)</code>","text":"<p>conver rgb to 24bit encoded int. int bitmap encoded as GGGGGGGGRRRRRRRRBBBBBBBB</p>"},{"location":"docs/colors/#backend.colors.tuple2hex","title":"<code>tuple2hex(t)</code>","text":"<p>Convert an RGB tuple to hex string</p>"},{"location":"docs/colors/#backend.colors.hex2tuple","title":"<code>hex2tuple(h)</code>","text":"<p>Convert a hex string to an RGB tuple</p>"},{"location":"docs/fizzle/","title":"Fizzle","text":"<p>Turns off a random LEDs</p>"},{"location":"docs/fizzle/#backend.fizzle.fizzle","title":"<code>fizzle()</code>","text":"<p>fizzle Fizzle out</p> <p>Randomly select a light on the tree and turn it off each time the function is called</p> example <pre><code>def draw():\n    yield from fizzle() # turn off all pixels randomly\n</code></pre>"},{"location":"docs/geometry/","title":"Geometry","text":"<p>Some helpful code for building Shapes for your patterns</p>"},{"location":"docs/geometry/#backend.geometry.Shape","title":"<code>Shape</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Shape Contains a shape</p> <p>A shape to be used for geometry</p> <p>Parameters:</p> Name Type Description Default <code>ABC</code> <code>ABC</code> <p>An abstract class</p> required"},{"location":"docs/geometry/#backend.geometry.Shape.does_draw","title":"<code>does_draw(pixel)</code>  <code>abstractmethod</code>","text":"<p>does_draw T.B.D</p> <p>Parameters:</p> Name Type Description Default <code>pixel</code> <code>Pixel</code> <p>T.B.D</p> required <p>Returns:</p> Type Description <code>Optional[Color]</code> <p>Optional[Color]: T.B.D</p>"},{"location":"docs/geometry/#backend.geometry.Sphere","title":"<code>Sphere(pos, radius, color)</code>","text":"<p>               Bases: <code>Shape</code></p> <p>Sphere a 3D circle </p> <p>Represents a spherical object</p> <p>Parameters:</p> Name Type Description Default <code>Shape</code> <code>Shape</code> <p>Must be an instance of Shape</p> required <p>init Create a sphere</p> <p>Create an instance of Sphere</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>tuple[float, float, float]</code> <p>The center point of the sphere [x, y, z]</p> required <code>radius</code> <code>float</code> <p>The radius of the sphere</p> required <code>color</code> <code>Color</code> <p>The color of the sphere</p> required"},{"location":"docs/geometry/#backend.geometry.Line","title":"<code>Line(a, b, stroke, color)</code>","text":"<p>               Bases: <code>Shape</code></p> <p>Line A line</p> <p>Has a starting point, end point, color, and a stroke</p> <p>Parameters:</p> Name Type Description Default <code>Shape</code> <code>Shape</code> <p>Must be an instance of Shape</p> required <p>init Create a line</p> <p>Create a new instance of Line</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>tuple[float, float, float]</code> <p>The start position of the line [x, y, z]</p> required <code>b</code> <code>tuple[float, float, float]</code> <p>The end position of the line [x, y, z]</p> required <code>stroke</code> <code>float</code> <p>The width of the line</p> required <code>color</code> <code>Color</code> <p>The color of the line</p> required"},{"location":"docs/gridmas/","title":"Gridmas","text":"<p>Import this module to include all the stuff you'll need.</p> <p>This module is a wraper for the following:</p> <ol> <li>util</li> <li>colors</li> <li>tree</li> <li>wipe</li> <li>fizzle</li> <li>attribute</li> <li>gemoetry</li> </ol> <p>Use this at the top of your pattern: <pre><code>from gridmas import *\n</code></pre></p>"},{"location":"docs/tree/","title":"Tree","text":"<p>Contains all the methods you need to change the tree. (Where the magic happens)</p>"},{"location":"docs/tree/#backend.tree.Tree","title":"<code>Tree()</code>","text":"<p>This is a class which holds the tree data, it shouldn't be used directly</p>"},{"location":"docs/tree/#backend.tree.Tree.init","title":"<code>init(tree_file)</code>","text":"<p>For internal use Initialise / reset the tree</p>"},{"location":"docs/tree/#backend.tree.height","title":"<code>height()</code>","text":"<p>The height of the tree</p> <p>Examples:</p> <p>if pixel.z &lt; height() / 2:     pixel.set_rgb(255, 255, 255)</p>"},{"location":"docs/tree/#backend.tree.num_pixels","title":"<code>num_pixels()</code>","text":"<p>The number of pixels, equivelant to len(pixels()) but faster</p>"},{"location":"docs/tree/#backend.tree.pixels","title":"<code>pixels(n=None)</code>","text":"<pre><code>pixels() -&gt; list[Pixel]\n</code></pre><pre><code>pixels(n: int) -&gt; Pixel\n</code></pre> <p>The main way of accessing pixels</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>Optional[int]</code> <p>Grab only the nth pixel</p> <code>None</code> <p>Examples:</p> <p>for pixel in pixels():     pixel.set_rgb(255, 255, 255)</p> <p>for i in range(num_pixels()):     pixels(i).set_rgb(255, 255, 255)</p>"},{"location":"docs/tree/#backend.tree.set_pixel","title":"<code>set_pixel(n, color)</code>","text":"<p>Set the Nth light in the strip to the specified color</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The light you want to set</p> required <code>color</code> <code>Color</code> <p>The color that you want to set the light to</p> required Example <pre><code>set_pixel(2, Color.black())\n</code></pre>"},{"location":"docs/tree/#backend.tree.set_fps","title":"<code>set_fps(fps)</code>","text":"<p>Allows you to change the speed that you want the animation to run at.    If unset, the default fps is 45</p> <p>Parameters:</p> Name Type Description Default <code>fps</code> <code>int</code> <p>target fps for the animation.</p> required Example <pre><code>set_fps(30)\ndef draw():\n    pass # called 30 times per second\n</code></pre>"},{"location":"docs/tree/#backend.tree.fade","title":"<code>fade(n=10)</code>","text":"<p>Fade the entire tree.     fades the tree to black over n frames Args:     n (int, optional): Unknown. Defaults to 10 Example:     <pre><code>def draw():\n    fade(10)\n</code></pre></p>"},{"location":"docs/tree/#backend.tree.background","title":"<code>background(c)</code>","text":"<p>Set the background color of the tree if a pixel hasn't been directly set or no shape overlaps the pixel, it will be drawn as the background color.</p> <p>removes any fading or lerping that might be applying</p> <p>example: <pre><code>background(Color.black())\ndef draw():\n    set_pixel(1, Color.white())\n</code></pre></p>"},{"location":"docs/tree/#backend.tree.fill","title":"<code>fill(color)</code>","text":"<p>Set all lights on the tree to one color</p> <p>This differs from background as it is part of the 1st rendering layer, directly setting pixels</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>Color</code> <p>The color you want to set the tree to</p> required"},{"location":"docs/tree/#backend.tree.lerp","title":"<code>lerp(color, frames, fn=linear)</code>","text":"<p>Lerp the entire tree from its current color to the target color over the specified amount of frames</p> <p>Once lerp has been called, it will automatically interpolate every frame to the target. Subsequent calls with the same parameters will continue the lerp, not reset.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>Color</code> <p>Target color</p> required <code>frames</code> <code>int</code> <p>The number of frames to perform the lerp over</p> required <code>fn</code> <code>Callable[[float], float]</code> <p>Timing function from the Util module. Defaults to linear.</p> <code>linear</code> Example <pre><code>def draw():\n    lerp(Color.black(), 10) # similar to fade\n</code></pre>"},{"location":"docs/tree/#backend.tree.coords","title":"<code>coords()</code>","text":"<p>An array of 3d coordinates mapped directly to the pixels coords()[10] gives the xyz tuple of the 10th pixel in the strip equivelant to pixels(10).xyz</p>"},{"location":"docs/tree/#backend.tree.sleep","title":"<code>sleep(n)</code>","text":"<p>sleep for n frames</p> example <pre><code>def draw():\n    lerp(Color.black(), 10)\n    yield from sleep(10)\n</code></pre>"},{"location":"docs/tree/#backend.tree.frame","title":"<code>frame()</code>","text":"<p>The current frame number since the start of the pattern example: <pre><code>def draw():\n    f = frame() # 1, 2, 3\n    print(f\"{f} frames since the pattern started\")\n</code></pre></p>"},{"location":"docs/tree/#backend.tree.seconds","title":"<code>seconds()</code>","text":"<p>The number of seconds since the start of the pattern</p>"},{"location":"docs/tree/#backend.tree.millis","title":"<code>millis()</code>","text":"<p>The number of milliseconds since the start of the pattern</p> example <pre><code>def draw():\n    s = seconds()\n    m = millis()\n    print(f\"{s}:{m} since the pattern started\")\n</code></pre>"},{"location":"docs/util/","title":"Utils","text":"<p>Holds a bunch of utility functions to make life easier</p>"},{"location":"docs/util/#backend.util.clamp","title":"<code>clamp(val, minv, maxv)</code>","text":"<p>Clamp a value between two values</p> example <pre><code>clamp(-1, 0, 1) # 0\nclamp(2, 0, 1) # 1\nclamp(0.5, 0, 1) # 0.5\n</code></pre>"},{"location":"docs/util/#backend.util.dist","title":"<code>dist(a, b)</code>","text":"<p>The distance between two vectors</p> example <pre><code>dist([0, 0], [3, 4]) # 5\n</code></pre>"},{"location":"docs/util/#backend.util.linear","title":"<code>linear(x)</code>","text":"<p>The linear activation function</p> <p>Activation function can be used with lerp to achieve different interpolations.</p> <p>The activations are taken from https://easings.net/# and are similar to the CSS implementations</p>"},{"location":"docs/util/#backend.util.step","title":"<code>step(x)</code>","text":"<p>The step activation function</p>"},{"location":"docs/util/#backend.util.ease_in_sine","title":"<code>ease_in_sine(x)</code>","text":"<p>The ease in sine activation function</p>"},{"location":"docs/util/#backend.util.ease_out_sine","title":"<code>ease_out_sine(x)</code>","text":"<p>The ease out sine activation function</p>"},{"location":"docs/util/#backend.util.ease_in_out_sine","title":"<code>ease_in_out_sine(x)</code>","text":"<p>The ease in out sine activation function</p>"},{"location":"docs/util/#backend.util.ease_in_cubic","title":"<code>ease_in_cubic(x)</code>","text":"<p>The ease in cubic activation function</p>"},{"location":"docs/util/#backend.util.ease_out_cubic","title":"<code>ease_out_cubic(x)</code>","text":"<p>The ease out cubic activation function</p>"},{"location":"docs/util/#backend.util.ease_in_out_cubic","title":"<code>ease_in_out_cubic(x)</code>","text":"<p>The ease in out cubic activation function</p>"},{"location":"docs/util/#backend.util.ease_in_quint","title":"<code>ease_in_quint(x)</code>","text":"<p>The ease in quint activation function</p>"},{"location":"docs/util/#backend.util.ease_out_quint","title":"<code>ease_out_quint(x)</code>","text":"<p>The ease out quint activation function</p>"},{"location":"docs/util/#backend.util.ease_in_out_quint","title":"<code>ease_in_out_quint(x)</code>","text":"<p>The ease in out quint activation function</p>"},{"location":"docs/util/#backend.util.ease_in_circ","title":"<code>ease_in_circ(x)</code>","text":"<p>The ease in circle activation function</p>"},{"location":"docs/util/#backend.util.ease_out_circ","title":"<code>ease_out_circ(x)</code>","text":"<p>The ease out circle activation function</p>"},{"location":"docs/util/#backend.util.ease_in_out_circ","title":"<code>ease_in_out_circ(x)</code>","text":"<p>The ease in out circle activation function</p>"},{"location":"docs/util/#backend.util.ease_in_elastic","title":"<code>ease_in_elastic(x)</code>","text":"<p>The ease in elastic activation function</p>"},{"location":"docs/util/#backend.util.ease_out_elastic","title":"<code>ease_out_elastic(x)</code>","text":"<p>The ease out elastic activation function</p>"},{"location":"docs/util/#backend.util.ease_in_out_elastic","title":"<code>ease_in_out_elastic(x)</code>","text":"<p>The ease in out elastic activation function</p>"},{"location":"docs/util/#backend.util.ease_in_quad","title":"<code>ease_in_quad(x)</code>","text":"<p>The ease in quad activation function</p>"},{"location":"docs/util/#backend.util.ease_out_quad","title":"<code>ease_out_quad(x)</code>","text":"<p>The ease out quad activation function</p>"},{"location":"docs/util/#backend.util.ease_in_out_quad","title":"<code>ease_in_out_quad(x)</code>","text":"<p>The ease in out quad activation function</p>"},{"location":"docs/util/#backend.util.ease_in_quart","title":"<code>ease_in_quart(x)</code>","text":"<p>The ease in quart activation function</p>"},{"location":"docs/util/#backend.util.ease_out_quart","title":"<code>ease_out_quart(x)</code>","text":"<p>The ease out quart activation function</p>"},{"location":"docs/util/#backend.util.ease_in_out_quart","title":"<code>ease_in_out_quart(x)</code>","text":"<p>The ease in out quart activation function</p>"},{"location":"docs/util/#backend.util.ease_in_expo","title":"<code>ease_in_expo(x)</code>","text":"<p>The ease in expo activation function</p>"},{"location":"docs/util/#backend.util.ease_out_expo","title":"<code>ease_out_expo(x)</code>","text":"<p>The ease out expo activation function</p>"},{"location":"docs/util/#backend.util.ease_in_out_expo","title":"<code>ease_in_out_expo(x)</code>","text":"<p>The ease in out expo activation function</p>"},{"location":"docs/util/#backend.util.ease_in_back","title":"<code>ease_in_back(x)</code>","text":"<p>The ease in back activation function</p>"},{"location":"docs/util/#backend.util.ease_out_back","title":"<code>ease_out_back(x)</code>","text":"<p>The ease out back activation function</p>"},{"location":"docs/util/#backend.util.ease_in_out_back","title":"<code>ease_in_out_back(x)</code>","text":"<p>The ease in out back activation function</p>"},{"location":"docs/util/#backend.util.ease_in_bounce","title":"<code>ease_in_bounce(x)</code>","text":"<p>The ease in bounce activation function</p>"},{"location":"docs/util/#backend.util.ease_out_bounce","title":"<code>ease_out_bounce(x)</code>","text":"<p>The ease out bounce activation function</p>"},{"location":"docs/util/#backend.util.ease_in_out_bounce","title":"<code>ease_in_out_bounce(x)</code>","text":"<p>The ease in out bounce activation function</p>"},{"location":"docs/wipe/","title":"Wipe","text":"<p>Use this module to wipe the tree with color. P.P.S please do not actually wipe the tree, the LEDs do not like being wet and may produce the magic smoke </p>"},{"location":"docs/wipe/#backend.wipe.wipe","title":"<code>wipe(theta, alpha, color, speed, fade=None)</code>","text":"<p>wipe A simple wipe</p> <p>Wipe a color from one side to the other. The angle is defined by Theta and Alpha. The prefered way to wipe a color on the tree is wipe_frames()</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>float</code> <p>Angle in radians</p> required <code>alpha</code> <code>float</code> <p>Angle in radians</p> required <code>color</code> <code>Color</code> <p>The color you are setting</p> required <code>speed</code> <code>int</code> <p>The speed of the animation</p> required <code>fade</code> <code>Color | None</code> <p>Possibly an in between color to be used during the wipe. Defaults to None.</p> <code>None</code>"},{"location":"docs/wipe/#backend.wipe.wipe_frames","title":"<code>wipe_frames(theta, alpha, color, frames=45, fade=None)</code>","text":"<p>wipe_frames wipe for n number of frames</p> <p>A more predictable version of wipe().</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>float</code> <p>Angle in radians</p> required <code>alpha</code> <code>float</code> <p>Angle in radians</p> required <code>color</code> <code>Color</code> <p>The colour to wipe to</p> required <code>frames</code> <code>int</code> <p>The exact number of frames that the wipe will take to complete. Defaults to 45.</p> <code>45</code> <code>fade</code> <code>Color | None</code> <p>The color the tree goes to after the wipe. Defaults to None.</p> <code>None</code>"},{"location":"docs/wipe/#backend.wipe.wipe_wave_frames","title":"<code>wipe_wave_frames(theta, alpha, color, frames=45, lerp_frame=20, lerp_fn=linear)</code>","text":"<p>wipe_wave_frames Wave for a number of frames</p> <p>Lerp pixels to the target color over the specified number of lerp frames. Produces more of a wave rather than a wipe.</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>float</code> <p>Angle in radians</p> required <code>alpha</code> <code>float</code> <p>Angle in radians</p> required <code>color</code> <code>Color</code> <p>The colour to wipe to</p> required <code>frames</code> <code>int</code> <p>The exact number of frames the animation will take to complete. Defaults to 45.</p> <code>45</code> <code>lerp_frame</code> <code>int</code> <p>The number of frames to lerp over. Defaults to 20.</p> <code>20</code> <code>lerp_fn</code> <code>Callable[[float], float]</code> <p>Unkown. Defaults to linear.</p> <code>linear</code>"},{"location":"samples/","title":"Code Samples","text":"<p>Welcome to the code samples section of the GRIDmas Tree docs. Here you can find the same sample code that is in the main portal of the GRIDmas Tree web editor, except with some more detail for context.</p>"},{"location":"samples/3D%20Fire/","title":"3D Fire","text":"<pre><code>from gridmas import *\nimport math\nimport random\n\nname = \"3D Fire\"\nauthor = \"Godzil\"\n# derived from https://github.com/standupmaths/xmastree2020/blob/main/examples/3dfire.py\n\n# Play with these values to change how coarse the 3D Fire effect is.\n# Smaller value == faster\nMATWX = 10\nMATWY = 10\nMATWZ = 30\n\n# Change that value to change colour brightness.\n# May need to tweak the palette if changing that value\nmaxBrightness = 255\n\n\nclass boundingBox():\n    def __init__(self):\n        self.minX = math.inf\n        self.maxX = -math.inf\n        self.minY = math.inf\n        self.maxY = -math.inf\n        self.minZ = math.inf\n        self.maxZ = -math.inf\n        self.wX = 0\n        self.wY = 0\n        self.wZ = 0\n\n    def update(self, x, y, z):\n        if self.minX &gt; x:\n            self.minX = x\n        if self.maxX &lt; x:\n            self.maxX = x\n\n        if self.minY &gt; y:\n            self.minY = y\n        if self.maxY &lt; y:\n            self.maxY = y\n\n        if self.minZ &gt; z:\n            self.minZ = z\n        if self.maxZ &lt; z:\n            self.maxZ = z\n\n    def finalize(self):\n        self.wX = self.maxX - self.minX\n        self.wY = self.maxY - self.minY\n        self.wZ = self.maxZ - self.minZ\n\n    def normalize(self, x, y, z):\n        lx = (x - self.minX) / self.wX\n        ly = (y - self.minY) / self.wY\n        lz = (z - self.minZ) / self.wZ\n        return lx, ly, lz\n\n\nclass matrix():\n    def __init__(self, lx, ly, lz, bb):\n        self._list = [0] * lx * ly * lz\n        self._strideX = 1\n        self._strideY = self._strideX * lx\n        self._strideZ = self._strideY * ly\n        self._bb = bb\n        self._wX = lx\n        self._wY = ly\n        self._wZ = lz\n\n    def get(self, x, y, z):\n        return self._list[x * self._strideX + y * self._strideY + z * self._strideZ]\n\n    def set(self, x, y, z, val):\n        self._list[x * self._strideX + y * self._strideY + z * self._strideZ] = val\n\n    def copy(self, other):\n        self._list = other._list[:]\n\n    def getTree(self, x, y, z):\n        localX, localY, localZ = self._bb.normalize(x, y, z)\n        localX = int(localX * (self._wX - 1))\n        localY = int(localY * (self._wY - 1))\n        localZ = int(localZ * (self._wZ - 1))\n        return self.get(localX, localY, localZ)\n\ncoords = coords()\n\ndef draw():\n    # Color are G R B\n    palette: list[tuple[int, int, int]] = []\n\n    # Transition points\n    palBST = 70\n    palB2R = 86  # Black to Red\n    palR2Y = 99  # Red to Yellow\n\n    # Black only\n    for i in range(0, palBST):\n        palette.append((0, 0, 0))\n    # Black to red\n    for i in range(palBST, palB2R):\n        palette.append((int((i - palBST) / (palB2R - palBST) * maxBrightness), 0, 0))\n    # red to yellow\n    for i in range(palB2R, palR2Y):\n        palette.append((maxBrightness, int((i - palB2R) / (palR2Y - palB2R) * maxBrightness), 0))\n    # yellow to white\n    for i in range(palR2Y, 256):\n        palette.append((255, 255, int((i - (palR2Y)) / (256 - palR2Y) * maxBrightness)))\n\n    treeBB = boundingBox()\n    for i in coords:\n        treeBB.update(i[0], i[1], i[2])\n\n    treeBB.finalize()\n\n    # Our working area. We work with a non code/cylinder shape as it\n    # would make thing too complicated\n    workMat = matrix(MATWX, MATWY, MATWZ, treeBB)\n    oldMat = matrix(MATWX, MATWY, MATWZ, treeBB)\n\n    while True:\n\n        for LED, pixel in enumerate(pixels()):\n            v = workMat.getTree(coords[LED][0], coords[LED][1], coords[LED][2])\n            pixel.set_rgb(*palette[v])\n\n        yield\n\n        oldMat.copy(workMat)\n\n        # Update the matrix\n        for x in range(1, MATWX - 1):\n            for y in range(1, MATWY - 1):\n                for z in range(2, MATWZ):\n                    v = oldMat.get(x, y, z - 2)\n                    v = v + oldMat.get(x - 1, y, z - 1)\n                    v = v + oldMat.get(x, y - 1, z - 1)\n                    v = v + oldMat.get(x, y, z - 1)\n                    v = v + oldMat.get(x, y + 1, z - 1)\n                    v = v + oldMat.get(x + 1, y, z - 1)\n                    v = max(min(int(v / 6), 255), 0)\n\n                    workMat.set(x, y, z, v)\n\n        # light the fire!\n        for x in range(0, MATWX):\n            for y in range(0, MATWY):\n                for z in range(0, 2):\n                    if random.uniform(0, 1) &lt; 0.35:\n                        workMat.set(x, y, z, 255)\n                    else:\n                        workMat.set(x, y, z, 0)\n</code></pre>"},{"location":"samples/3D%20Plasma/","title":"3D Plasma","text":"<pre><code>import math\nfrom gridmas import *\n\n# derived from https://github.com/standupmaths/xmastree2020/blob/main/examples/3dplasma.py\n\n# Play with these values to change how coarse the plasma effect is.\n# Smaller value == faster\nMATWX = 7\nMATWY = 8\nMATWZ = 25\n\n# Set this value to lower the RGB (1 = full range, 0.5 = Half range, etc...)\ndimLight = 0.8\n\n\nclass boundingBox():\n    def __init__(self):\n        self.minX = math.inf\n        self.maxX = -math.inf\n        self.minY = math.inf\n        self.maxY = -math.inf\n        self.minZ = math.inf\n        self.maxZ = -math.inf\n        self.wX = 0\n        self.wY = 0\n        self.wZ = 0\n\n    def update(self, x, y, z):\n        if self.minX &gt; x:\n            self.minX = x\n        if self.maxX &lt; x:\n            self.maxX = x\n\n        if self.minY &gt; y:\n            self.minY = y\n        if self.maxY &lt; y:\n            self.maxY = y\n\n        if self.minZ &gt; z:\n            self.minZ = z\n        if self.maxZ &lt; z:\n            self.maxZ = z\n\n    def finalize(self):\n        self.wX = self.maxX - self.minX\n        self.wY = self.maxY - self.minY\n        self.wZ = self.maxZ - self.minZ\n\n    def normalize(self, x, y, z):\n        lx = (x - self.minX) / self.wX\n        ly = (y - self.minY) / self.wY\n        lz = (z - self.minZ) / self.wZ\n        return lx, ly, lz\n\n\nclass matrix():\n    def __init__(self, lx, ly, lz, bb):\n        self._list = []\n        for _ in range(lx * ly * lz):\n            self._list.append([0, 0, 0])\n\n        self._strideX = 1\n        self._strideY = self._strideX * lx\n        self._strideZ = self._strideY * ly\n        self._bb = bb\n        self._wX = lx\n        self._wY = ly\n        self._wZ = lz\n\n    def get(self, x, y, z):\n        return self._list[x * self._strideX + y * self._strideY + z * self._strideZ]\n\n    def set(self, x, y, z, val):\n        self._list[x * self._strideX + y * self._strideY + z * self._strideZ] = val\n\n    def getTree(self, x, y, z):\n        localX, localY, localZ = self._bb.normalize(x, y, z)\n        localX = int(localX * (self._wX - 1))\n        localY = int(localY * (self._wY - 1))\n        localZ = int(localZ * (self._wZ - 1))\n        return self.get(localX, localY, localZ)\n\n\ndef dist(x, y, z, wx, wy, wz):\n    return math.sqrt((x - wx) * (x - wx) + (y - wy) * (y - wy) + (z - wz) * (z - wz))\n\ncoords = coords()\n\n\ntreeBB = boundingBox()\nfor i in coords:\n    treeBB.update(i[0], i[1], i[2])\n\ntreeBB.finalize()\n\nworkMat = matrix(MATWX, MATWY, MATWZ, treeBB)\n\nt = 0\n\n\ndef draw():\n    global t\n\n    for LED, pixel in enumerate(pixels()):\n        pixel.set_rgb(*map(lambda x: int(x), workMat.getTree(coords[LED][0], coords[LED][1], coords[LED][2])))\n\n\n    # Update the matrix\n    for x in range(0, MATWX):\n        for y in range(0, MATWY):\n            for z in range(0, MATWZ):\n                d1 = dist(x + t, y, z, MATWX, MATWY, MATWZ)\n                d2 = dist(x, y, z, MATWX / 2, MATWY / 2, MATWZ)\n                d3 = dist(x, y + t / 7, z, MATWX * 0.75, MATWY / 2, MATWZ)\n                d4 = dist(x, y, z, MATWX * 0.75, MATWY, MATWZ)\n\n                value = math.sin(d1 / 8) + math.sin(d2 / 8.0) + math.sin(d3 / 7.0) + math.sin(d4 / 8.0)\n\n                colour = int((4 + value)) * 32\n                r = min(colour, 255) * dimLight\n                g = min(colour * 2, 255) * dimLight\n                b = min(255 - colour, 255) * dimLight\n\n                workMat.set(x, y, z, (g, r, b))\n    t = t + 1\n</code></pre>"},{"location":"samples/Center%20Finder/","title":"Center Finder","text":"<pre><code>from gridmas import *\n\nname = \"Center Finder\"\nauthor = \"Ciaran\"\n\n\nportion = RangeAttr(\"position\", 0, -1, 1, 0.01)\ndef draw():\n    global portion\n\n    for pixel in pixels():\n        if pixel.y &gt; portion.get():\n            pixel.set_rgb(200, 0, 0)\n        else:\n            pixel.set_rgb(0, 0, 200)\n</code></pre>"},{"location":"samples/Color%20Switcher/","title":"Color Switcher","text":"<pre><code>from gridmas import *\n\nname = \"Color Switcher\"\nauthor = \"Murtaza\"\nnum_colors = 2\n\nset_fps(1)\n\ndef draw():\n\n    colors = [Color.random() for i in range(num_colors)]\n    while True:\n        for pixel_index, pixel in enumerate(pixels()):\n            for color_index, color in enumerate(colors):\n                if pixel_index % num_colors == color_index:\n                    pixel.set_color(color)\n        yield\n        for _ in range(45):\n            yield\n        colors = [Color.different_from(color) for color in colors]\n</code></pre>"},{"location":"samples/Fade%20Waves/","title":"Fade Waves","text":"<pre><code>from gridmas import *\nimport random\n\n\nname = \"Fade Planes\"\nauthor = \"Ciaran\"\n\nspeed = RangeAttr(\"speed\", 45, 30, 90, 1)\n\ndef draw():\n    color = Color(255, 255, 0)\n    while True:\n        theta = random.uniform(0, 6.28)\n        alpha = random.uniform(0, 6.28)\n        yield from wipe_frames(theta, alpha, color, int(speed.get()), Color.black())\n        color = Color.different_from(color)\n</code></pre>"},{"location":"samples/Fireworks/","title":"Fireworks","text":"<pre><code>from gridmas import *\nimport random\n\nname = \"Fire Works\"\nauthor = \"Ciaran\"\n\n\nclass Explosion():\n    def __init__(self, x, y, z, max_age):\n        self.x = x\n        self.y = y\n        self.z = z\n        self.max_age = max_age\n        self.tick = 0\n        self.color = Color.random()\n\n\ndef draw():\n    explosions: list[Explosion] = []\n    i = 0\n    interval = 50\n    while True:\n        if i == 0:\n            randomid = random.randrange(0, num_pixels() - 1)\n            center_light = pixels(randomid)\n            explosions.append(Explosion(center_light.x, center_light.y, center_light.z, 5))\n            interval = random.randrange(50, 140)\n        i = (i + 1) % interval\n\n        for exp in explosions:\n            exp.tick += 1\n\n        for pixel in pixels():\n            a = random.random()\n            if a &gt; 0.8:\n                pixel.fade(random.randrange(100, 120, 1) / 100)\n            elif a &gt; 0.77:\n                pixel.set_color(Color.black())\n            elif a &gt; 0.765:\n                pixel.fade(0.5)\n\n            for exp in explosions:\n                if exp.tick / 6 &lt; dist([exp.x, exp.y, exp.z], [pixel.x, pixel.y, pixel.z]) &lt; exp.tick / 5:\n                    pixel.set_color(exp.color)\n\n        yield\n        explosions = list(filter(lambda x: x.tick &lt;= x.max_age, explosions))\n</code></pre>"},{"location":"samples/Helix%20Spin/","title":"Helix Spin","text":"<pre><code>import time\nimport math\nfrom gridmas import *\n\nname = \"Helix Spin\"\nauthor = \"chatGPT\"\n\n# Constants for the HelixSpin pattern\nASCENT_SPEED = 0.01  # Speed of movement upwards\nCOLOR_CYCLE_SPEED = 0.05  # Speed of color change\n\nangle_offset = 0  # Current angle offset for spinning\nvertical_offset = 0  # Current vertical offset for moving upwards\n\nHELIX_STRANDS = RangeAttr(\"helix strands\", 1, 0, 4, 1)  # Number of strands in the helix\nSPIN_SPEED = RangeAttr(\"spin speed\", 0.08, 0.06, 0.24, 0.01)  # Speed of spinning around the tree\ntwist = RangeAttr(\"Twist\", 6, 1, 20, 0.5)\n\ndef draw():\n    global angle_offset, vertical_offset, HELIX_STRANDS, SPIN_SPEED, twist\n\n\n\n    # Each frame, calculate the color based on a simple cycling pattern\n    r = int((math.sin(COLOR_CYCLE_SPEED * seconds()) + 1) / 2 * 255)\n    g = int((math.sin(COLOR_CYCLE_SPEED * seconds() + 2 * math.pi / 3) + 1) / 2 * 255)\n    b = int((math.sin(COLOR_CYCLE_SPEED * seconds() + 4 * math.pi / 3) + 1) / 2 * 255)\n\n    for pixel in pixels():\n\n        # Calculate the angle of this point around the center of the tree\n        angle = math.atan2(pixel.y, pixel.x)\n        # Determine the strand by position along the z-axis and the number of strands\n        strand = int((HELIX_STRANDS.get() * (pixel.z / height() + vertical_offset)) % HELIX_STRANDS.get())\n\n        # Check if the light is close to the helix for this strand\n        if abs((angle - angle_offset - 2 * math.pi * strand / HELIX_STRANDS.get() + pixel.z * twist.get()) % (2 * math.pi) &lt; 0.2 or (angle - angle_offset - 2 * math.pi * strand / HELIX_STRANDS.get() + pixel.z * twist.get()) % (2 * math.pi) &gt; 2 * math.pi - 0.2):\n            # Set the color for lights close to the helix part\n            pixel.set_color(Color(r, g, b))\n        else:\n            # Dim other lights\n            pixel.fade(1.1)\n\n\n    # Move the helix\n    angle_offset = (angle_offset + SPIN_SPEED.get()) % (2 * math.pi)\n    vertical_offset = (vertical_offset + ASCENT_SPEED) % 1\n</code></pre>"},{"location":"samples/Hue%20Rotate/","title":"Hue Rotate","text":"<pre><code>from gridmas import *\n\nname = \"Hue Rotate\"\nauthor = \"Ciaran\"\n\nhue = 0\nspeed = RangeAttr(\"speed\", 0.003, -0.005, 0.005, 0.0001)\n\ndef draw():\n    global hue, speed\n\n    hue = (hue + speed.get()) % 1\n    for pixel in pixels():\n        pixel.set_hsl(hue, 1, 0.5)\n</code></pre>"},{"location":"samples/Jumpy%20Balls/","title":"Jumpy Balls","text":"<pre><code>from gridmas import *\nimport random\n\n\n\nname = \"Jumpy Balls\"\nauthor = \"Ciaran\"\n\nclass Ball:\n    def __init__(self):\n\n        self.c = Color.random()\n        self.x = random.random() - 0.5\n        self.y = random.random() - 0.5\n        self.z = height()\n        self.xVel = (random.random() - 0.5) * 0.3\n        self.yVel = (random.random() - 0.5) * 0.3\n        self.zVel = (1 - random.random()) * 0.03\n\n\n\n\n\ndef draw():\n    balls = []\n\n\n    while True:\n        balls.append(Ball())\n        if len(balls) &gt; 5:\n            balls.pop(0)\n        for _ in range(random.randrange(50, 100)):\n            lerp(Color(0, 0, 0), 5)\n            for ball in balls:\n                Sphere((ball.x, ball.y, ball.z), 0.2, ball.c)\n\n                ball.zVel -= 0.03\n                ball.z += ball.zVel\n                ball.x += ball.xVel\n                ball.y += ball.yVel\n\n                if ball.z &lt; 0:\n                    ball.zVel *= -0.9\n                    ball.z = 0.1\n                if ball.x &gt; 0.8 or ball.x &lt; -0.8:\n                    ball.xVel *= -0.9\n                    ball.yVel += (random.random() - 0.5) * 0.1\n                if ball.y &gt; 0.8 or ball.y &lt; -0.8:\n                    ball.yVel *= -0.9\n                    ball.xVel += (random.random() - 0.5) * 0.1\n\n            yield\n</code></pre>"},{"location":"samples/Murica/","title":"Murica","text":"<pre><code>import random\nfrom gridmas import *\n\nname = \"murca\"\nauthor = \"Ciaran\"\n\n\ndef draw():\n    y = 0\n\n    stars = [random.randint(0, num_pixels()) for _ in range(100)]\n\n    while True:\n        y = (y + 0.01) % height()\n        for pixel in pixels():\n            if ((pixel.z + y) % height() * 2 &gt;= height()):\n                # do stars\n                pixel.set_rgb(0, 0, 255)\n\n        for star in stars:\n            pixels()[star].set_rgb(200, 200, 200)\n\n        for pixel in pixels():\n            if not ((pixel.z + y) % height() * 2 &gt;= height()):\n                if (pixel.x % 0.6) &gt; 0.3:\n                    pixel.set_rgb(255, 0, 0)\n                else:\n                    pixel.set_rgb(200, 200, 200)\n        yield\n</code></pre>"},{"location":"samples/RGB%20Helix/","title":"RGB Helix","text":"<pre><code>import math\nfrom gridmas import *\nimport random\n\nname = \"RGB Helix\"\nauthor = \"Ciaran\"\n\ntwist_dx = RangeAttr(\"twist speed\", 0.01, 0.001, 0.2, 0.001)\nrotate_amount = RangeAttr(\"Rotate speed\", 0.01, 0.001, 0.1, 0.001)\ntwist_dir = 1\ntwist_amount = -random.randrange(-8, 8)\nspeed = 2\noffset = random.random() * math.pi * 2\ncolor_offset = random.random()\n\ndef draw():\n    global twist_amount,twist_dir, offset, color_offset\n\n    for pixel in pixels():\n\n        modified_angle = (pixel.a + pixel.z * twist_amount + offset * speed) % (math.pi * 2)\n\n        a = round((modified_angle) / math.pi)\n\n        hue = a / 2\n        pixel.set_color(Color.hsl((hue + color_offset) % 1, 1, 0.5))\n\n\n    offset = (offset + rotate_amount.get()) % (math.pi * 2)\n\n    color_offset = (0.00027 + color_offset) % 1\n\n    twist_amount += twist_dir * twist_dx.get()\n    if twist_amount &gt; 10:\n        twist_dir = -1\n    elif twist_amount &lt; -10:\n        twist_dir = 1\n</code></pre>"},{"location":"samples/RGB%20Spheres/","title":"RGB Spheres","text":"<pre><code>import math\nimport random\nfrom gridmas import *\n\nname = \"RGB Helix\"\nauthor = \"Ciaran\"\n\ntwist_dx = RangeAttr(\"twist speed\", 0.01, 0.001, 0.2, 0.001)\nrotate_amount = RangeAttr(\"Rotate speed\", 0.01, 0.001, 0.1, 0.001)\ntwist_dir = 1\ntwist_amount = -random.randrange(-8, 8)\nspeed = 2\noffset = random.random() * math.pi * 2\ncolor_offset = random.random()\n\ndef draw():\n    global twist_amount,twist_dir, offset, color_offset\n\n    for pixel in pixels():\n\n        modified_angle = (pixel.a + pixel.z * twist_amount + offset * speed) % (math.pi * 2)\n\n        a = round((modified_angle) / math.pi)\n\n        hue = a / 2\n        pixel.set_color(Color.hsl((hue + color_offset) % 1, 1, 0.5))\n\n\n    offset = (offset + rotate_amount.get()) % (math.pi * 2)\n\n    color_offset = (0.00027 + color_offset) % 1\n\n    twist_amount += twist_dir * twist_dx.get()\n    if twist_amount &gt; 10:\n        twist_dir = -1\n    elif twist_amount &lt; -10:\n        twist_dir = 1\n</code></pre>"},{"location":"samples/Rippling%20Waves/","title":"Rippling Waves","text":"<pre><code>from gridmas import *\n\nname = \"Rippling Waves\"\nauthor = \"Claude 3.5\"\n\nwave_speed = RangeAttr(\"Wave Speed\", 0.1, 0.01, 0.5, 0.01)\nwave_frequency = RangeAttr(\"Wave Frequency\", 2.0, 0.5, 5.0, 0.1)\ncolor_speed = RangeAttr(\"Color Speed\", 0.02, 0.01, 0.1, 0.01)\nprimary_color = ColorAttr(\"Primary Color\", Color(255, 0, 0))\nsecondary_color = ColorAttr(\"Secondary Color\", Color(0, 0, 255))\n\ndef draw():\n\n    time = 0\n    while True:\n        for i, pixel in enumerate(pixels()):\n            # Calculate the wave based on height (z-coordinate) and time\n            wave = math.sin(wave_frequency.get() * (pixel.z / height() * 2 * math.pi + time))\n\n            # Map the wave to a value between 0 and 1\n            wave_mapped = (wave + 1) / 2\n\n            # Interpolate between primary and secondary colors\n            r = int(primary_color.get().r * wave_mapped + secondary_color.get().r * (1 - wave_mapped))\n            g = int(primary_color.get().g * wave_mapped + secondary_color.get().g * (1 - wave_mapped))\n            b = int(primary_color.get().b * wave_mapped + secondary_color.get().b * (1 - wave_mapped))\n\n            # Add a radial component based on distance from the center\n            distance = math.sqrt(pixel.x**2 + pixel.y**2)\n            radial_factor = (math.sin(distance * wave_frequency.get() * 2 + time) + 1) / 2\n\n            # Combine the vertical wave with the radial component\n            combined_factor = (wave_mapped + radial_factor) / 2\n\n            # Set the final color\n            pixel.set_rgb(\n                int(r * combined_factor),\n                int(g * combined_factor),\n                int(b * combined_factor)\n            )\n\n        yield\n        time += wave_speed.get()\n\n        # Slowly shift the primary and secondary colors\n        hue_shift = color_speed.get()\n        primary_color.set(Color.hsl((time * hue_shift) % 1, 1, 0.5))\n        secondary_color.set(Color.hsl(((time * hue_shift) + 0.5) % 1, 1, 0.5))\n</code></pre>"},{"location":"samples/Solid%20Color/","title":"Solid Color","text":"<pre><code>from gridmas import *\n\nname = \"Solid Color\"\nauthor = \"Ciaran\"\n\ncol = ColorAttr(\"Color\", Color(200, 20, 0))\n\ndef draw():\n    for pixel in pixels():\n        pixel.set_color(col.get())\n</code></pre>"},{"location":"samples/Sphere%20Fill/","title":"Sphere Fill","text":"<pre><code>import math\nfrom gridmas import *\n\nname = \"Spin\"\nauthor = \"Ciaran\"\n# based on Matt Parkers xmas tree\n\nspeed = RangeAttr(\"speed\", 0.02, -0.1, 0.1, 0.001)\ncolor1 = ColorAttr(\"color 1\", Color(0, 50, 50))\ncolor2 = ColorAttr(\"color 2\", Color(50, 50, 0))\n\nheights: list[float] = []\nfor i in coords():\n    heights.append(i[2])\n\nangle = 0\n\n# the starting point on the vertical axis\nc = -height() / 2\n\ndef draw():\n    global angle\n\n    for pixel in pixels():\n        # figure out if the pixel is above or below the plane\n        if (math.tan(angle) * pixel.x &lt;= pixel.z + c) ^ (angle &gt; 0.5 * math.pi) ^ (angle &gt;= 1.5 * math.pi):\n            pixel.set_color(color1.get())\n        else:\n            pixel.set_color(color2.get())\n\n    # now we get ready for the next cycle\n\n    angle = (angle + speed.get()) % (2 * math.pi)\n</code></pre>"},{"location":"samples/Starry%20Night/","title":"Starry Night","text":"<pre><code>import random\nimport math\nfrom gridmas import *\n\nname = \"Starry Night\"\nauthor = \"Claude 3.5\"\n\n\nclass Star:\n    def __init__(self, index, brightness):\n        self.index = index\n        self.brightness = brightness\n        self.twinkle_speed = random.uniform(0.02, 0.1)\n        self.twinkle_offset = random.uniform(0, 2 * math.pi)\n\n\nclass ShootingStar:\n    def __init__(self, start_index, direction, speed):\n        self.current_index = start_index\n        self.direction = direction\n        self.speed = speed\n        self.life = 1.0\n\n\nstar_density = RangeAttr(\"Star Density\", 0.1, 0.05, 0.3, 0.01)\nshooting_star_chance = RangeAttr(\"Shooting Star Chance\", 0.01, 0.001, 0.05, 0.001)\n\nbackground_color = Color(0, 0, 0)  # Dark blue night sky\nstar_color = ColorAttr(\"Star Color\", Color(255, 255, 200))  # Warm white\n\ndef draw():\n\n    stars = []\n    shooting_stars = []\n    time = 0\n\n    # Initialize stars\n    for i in range(num_pixels()):\n        if random.random() &lt; star_density.get():\n            stars.append(Star(i, random.uniform(0.1, 1.0)))\n\n    while True:\n        # Clear the tree\n        for pixel in pixels():\n            pixel.set_black()\n\n\n        # Update and draw stars\n        for star in stars:\n            brightness = star.brightness * (0.5 + 0.5 * math.sin(time * star.twinkle_speed + star.twinkle_offset))\n            color = Color(\n                int(star_color.get().r * brightness),\n                int(star_color.get().g * brightness),\n                int(star_color.get().b * brightness)\n            )\n            set_pixel(star.index, color)\n\n        # Update and draw shooting stars\n        for shooting_star in shooting_stars:\n            color = Color(\n                int(star_color.get().r * shooting_star.life),\n                int(star_color.get().g * shooting_star.life),\n                int(star_color.get().b * shooting_star.life)\n            )\n            set_pixel(int(shooting_star.current_index % num_pixels()), color)\n\n            # Move the shooting star\n            shooting_star.current_index += shooting_star.speed * shooting_star.direction\n            shooting_star.life -= 0.05\n\n        # Remove dead shooting stars\n        shooting_stars = [ss for ss in shooting_stars if ss.life &gt; 0]\n\n        # Chance to add a new shooting star\n        if random.random() &lt; shooting_star_chance.get():\n            start_index = random.randint(0, num_pixels() - 1)\n            direction = 1 if random.random() &lt; 0.5 else -1\n            speed = random.uniform(0.5, 2.0)\n            shooting_stars.append(ShootingStar(start_index, direction, speed))\n\n        yield\n        time += 0.1\n\n        # Occasionally add or remove stars\n        if random.random() &lt; 0.01:\n            if random.random() &lt; 0.5 and len(stars) &gt; 0:\n                stars.pop(random.randint(0, len(stars) - 1))\n            elif len(stars) &lt; num_pixels() * star_density.get():\n                new_index = random.randint(0, num_pixels() - 1)\n                if new_index not in [star.index for star in stars]:\n                    stars.append(Star(new_index, random.uniform(0.1, 1.0)))\n</code></pre>"},{"location":"samples/Twinkling%20Stars/","title":"Twinkling Stars","text":"<pre><code>import random\nfrom gridmas import *\n\nstar_color = Color(255, 255, 255)  # Star color - white\nsky_color = Color(15, 15, 40)  # Dark \"sky\" color - deep blue\ntwinkling_frequency = 0.1  # Chance of a light twinkling each second\n\ndef draw():\n    for pixel in pixels():\n        if random.random() &lt; twinkling_frequency:\n            if random.random() &gt; 0.5:\n                pixel.set_color(star_color)\n            else:\n                pixel.set_color(sky_color)\n</code></pre>"},{"location":"samples/Wandering%20Ball/","title":"Wandering Ball","text":"<pre><code>import random\nimport math\n\nfrom gridmas import *\n\nname = \"Wandering Ball\"\nauthor = \"Ciaran\"\n\n\ncur_height = 0.5\nangle = random.randrange(0, 627) / 100\nangle2 = random.randrange(0, 627) / 100\n\ndist = 0.3\nradius = RangeAttr(\"radius\", 0.4, 0.1, 0.8, 0.03)\ncolor = ColorAttr(\"ball color\", Color.white())\ntrailLength = RangeAttr(\"Trail Length\", 100, 5, 200, 5)\n\ndef draw():\n    global angle, cur_height, angle2, dist\n    lerp(Color.black(), int(trailLength.get()))\n\n    angle = (angle + 0.1) % 6.28\n    angle2 = (angle2 + 0.034) % 6.28\n\n    center = [dist * math.sin(angle), dist * math.cos(angle), cur_height]\n    cur_height = abs(math.sin(angle2)) * (height() - radius.get() * 2) + radius.get()\n    Sphere((center[0], center[1], cur_height), radius.get(), color.get())\n</code></pre>"},{"location":"samples/Wave%20Flow/","title":"Wave Flow","text":"<pre><code>from gridmas import *\nimport time\nimport math\n\nwave_offset = 0  # this will move the wave up along the z-axis (height)\ndef draw():\n    global wave_offset\n    wave_speed = 0.03\n    wave_period = 0.5\n    color_change_rate = 0.2\n\n    # slowly change color over time for the wave (rainbow-like cycle)\n    r = int((math.sin(color_change_rate * time.time()) + 1) / 2 * 255)\n    g = int((math.sin(color_change_rate * time.time() + 2 * math.pi / 3) + 1) / 2 * 255)\n    b = int((math.sin(color_change_rate * time.time() + 4 * math.pi / 3) + 1) / 2 * 255)\n    wave_color = (r, g, b)\n\n    for pixel in pixels():\n        # a basic 3d wave function based on the z-coordinate and a changing 'wave_offset'\n        intensity = 0.5 * (math.cos(2 * math.pi * (pixel.z / height() + wave_offset) / wave_period) + 1)\n        # using intensity to modify the brightness of the color\n        wave_intensity_color = Color(int(wave_color[0] * intensity), int(wave_color[1] * intensity), int(wave_color[2] * intensity))\n\n        # set the light to the calculated color\n        pixel.set_color(wave_intensity_color)\n\n        # increase the wave offset to move the wave upwards\n    wave_offset = (wave_offset + wave_speed) % (6)\n</code></pre>"},{"location":"samples/XYZ%20Planes%20Original/","title":"XYZ Planes Original","text":"<pre><code>from gridmas import *\nimport math\n\nname = \"XYZ Planes2\"\nauthor = \"Ciaran\"\n\n\nspeed = RangeAttr(\"speed\", 45, 30, 60, 1)\ndef draw():\n\n    dirs = [(0, 0), (math.pi / 2, 0), (math.pi / 2, math.pi / 2), (math.pi / 2, math.pi), (math.pi / 2, math.pi * 1.5), (math.pi, 0)]\n\n    color = Color.random()\n    while True:\n        for dir in dirs:\n            color = Color.different_from(color)\n            yield from wipe_frames(dir[0], dir[1], color, int(speed.get()), Color.black())\n</code></pre>"},{"location":"samples/XYZ%20Planes/","title":"XYZ Planes","text":"<pre><code>from gridmas import *\nimport math\n\nname = \"XYZ Planes\"\nauthor = \"Ciaran\"\n\n\nspeed = RangeAttr(\"speed\", 10, 1, 14, 1)\ndef draw():\n\n    dirs = [(0, 0), (math.pi / 2, math.pi / 2), (math.pi / 2, 0)]\n\n    color = Color.random()\n    while True:\n        for dir in dirs:\n            color = Color.different_from(color)\n            yield from wipe(dir[0], dir[1], color, int(speed.get()), Color.black())\n</code></pre>"},{"location":"samples/bad_apple/","title":"bad_apple","text":"<pre><code>import cv2\nfrom gridmas import *\n\nname = \"Bad Apple\"\nauthor = \"Ciaran\"\n\n\ndef draw():\n    cap = cv2.VideoCapture(\"patterns/badapple.mp4\")\n    coords = []\n\n    for pixel in pixels():\n        videox = max(min(int(((-pixel.x + 1) / 2) * 480), 479), 0)\n        videoy = max(min(int((1 - pixel.z / 2) * 360), 359), 0)\n        coords.append((videox, videoy))\n\n    set_fps(30)\n\n    while True:\n\n        ret, frame = cap.read()\n        if not ret:\n            break\n\n        for i, pixel in enumerate(pixels()):\n            if 0.5 &lt; pixel.z &lt; 2.5:\n                value = int(frame[coords[i][1]][coords[i][0]][0])\n                pixel.set_rgb(value, value, value)\n\n            else:\n                pixel.set_rgb(0, 0, 0)\n        yield\n\n    cap.release()\n</code></pre>"},{"location":"samples/borealis/","title":"Borealis","text":"<pre><code>from gridmas import *\nimport math\nimport random\n\nname = \"Aurora Borealis\"\nauthor = \"Claude 3.5\"\n\nflow_speed = RangeAttr(\"Flow Speed\", 0.02, 0.01, 0.1, 0.01)\ncolor_shift_speed = RangeAttr(\"Color Shift Speed\", 0.01, 0.001, 0.05, 0.001)\nwave_frequency = RangeAttr(\"Wave Frequency\", 1.5, 0.5, 3.0, 0.1)\nsparkle_chance = RangeAttr(\"Sparkle Chance\", 0.0005, 0.0001, 0.01, 0.0001)\n\ndef draw():\n\n\n    color1 = Color(0, 255, 100)  # Green\n    color2 = Color(100, 200, 255)  # Light blue\n    color3 = Color(255, 100, 200)  # Pink\n\n    time = 0\n    while True:\n        for i, pixel in enumerate(pixels()):\n            # Calculate the base wave using the pixel's x and y coordinates\n            wave = math.sin(wave_frequency.get() * (pixel.x + pixel.y) + time)\n\n            # Add vertical movement\n            wave += math.sin(wave_frequency.get() * 0.5 * pixel.z + time * 1.5)\n\n            # Normalize the wave to [0, 1]\n            wave = (wave + 2) / 4\n\n            # Calculate color based on the wave and time\n            if wave &lt; 0.33:\n                factor = wave * 3\n                color = Color.mix(color1, color2, factor)\n            elif wave &lt; 0.67:\n                factor = (wave - 0.33) * 3\n                color = Color.mix(color2, color3, factor)\n            else:\n                factor = (wave - 0.67) * 3\n                color = Color.mix(color3, color1, factor)\n\n            # Add occasional sparkle\n            if random.random() &lt; sparkle_chance.get():\n                color = Color(255, 255, 255)  # White sparkle\n\n            set_pixel(i, color)\n\n        yield\n        time += flow_speed.get()\n\n        # Slowly shift the colors over time\n        hue_shift = color_shift_speed.get()\n        color1 = Color.hsl((time * hue_shift) % 1, 1, 0.5)\n        color2 = Color.hsl(((time * hue_shift) + 0.33) % 1, 1, 0.6)\n        color3 = Color.hsl(((time * hue_shift) + 0.67) % 1, 1, 0.7)\n</code></pre>"},{"location":"samples/caduceus/","title":"Caduceus","text":"<pre><code>from gridmas import *\nimport random\nimport math\n\nname = \"Caduceus\"\nauthor = \"Ciaran\"\n\nradius = 0.15\n\n\nclass Particle:\n    def __init__(self):\n        self.z = -radius\n        self.angle = random.random() * 2 * math.pi\n        self.dist = random.randint(2, 7) / 10\n        self.pitch = random.randint(15, 25) / 100\n        self.speed = random.randint(3, 10) / 100\n        self.col = Color.random()\n\nparticles = []\n\ndef draw():\n    global particles\n    particles = list(filter(lambda x: x.z &lt; height(), particles))\n\n    for p in particles:\n        p.z += p.speed\n        p.angle += p.pitch\n        p.x = p.dist * math.sin(p.angle)\n        p.y = p.dist * math.cos(p.angle)\n        Sphere([p.x, p.y, p.z], radius, p.col)\n\n    lerp(Color.black(), 10)\n\n    if frame() % 20 == 0:\n        particles.append(Particle())\n</code></pre>"},{"location":"samples/checkers/","title":"Checkers","text":"<pre><code>from gridmas import *\n\nname = \"Checkers\"\nauthor = \"Ciaran\"\n\n\ndef draw():\n    if frame() % 100 == 0:\n        color1 = Color.random()\n        color2 = Color.different_from(color1)\n        for pixel in pixels():\n            x = 0\n            if pixel.x % 2 &gt; 1:\n                x ^= 1\n            if pixel.y % 2 &gt; 1:\n                x ^= 1\n            if pixel.z % 2 &gt; 1:\n                x ^= 1\n            if x == 0:\n                pixel.lerp(color1, 10)\n            else:\n                pixel.lerp(color2, 10)\n</code></pre>"},{"location":"samples/fountain/","title":"Fountain","text":"<pre><code>from gridmas import *\nimport math\nimport random\n\n\n\nname = \"Fountain\"\nauthor = \"Ciaran\"\n\n\nclass Dropplet:\n    def __init__(self):\n        self.x = 0\n        self.y = 0\n        self.z = 0\n        self.zAcl = -0.003\n        self.zVel = 0.1\n        self.xVel = 0.008\n        self.dist = 0\n        self.angle = random.random() * 2 * math.pi\n\n\ndef draw():\n    snowflakes = []\n    while True:\n        snowflakes = list(filter(lambda x: x.z &gt; -0.2, snowflakes))\n\n        fade(10)\n        for _ in range(random.randint(2, 3)):\n\n            for flake in snowflakes:\n                Sphere((flake.x, flake.y, flake.z), 0.15, Color(100,100,240))\n\n                flake.z += flake.zVel\n                flake.zVel += flake.zAcl\n\n                flake.x = flake.dist * math.sin(flake.angle)\n                flake.y = flake.dist * math.cos(flake.angle)\n\n                flake.dist += flake.xVel\n\n            yield\n\n        snowflakes.append(Dropplet())\n</code></pre>"},{"location":"samples/harderStronger/","title":"harderstronger","text":"<pre><code>from colors import Color\nfrom gridmas import *\n\nname = \"Harder Better Faster Stronger\"\nauthor = \"Ciaran\"\n\n\ndef draw():\n    # each second is 40 frames, the song is 123 bpm which is 41 fps\n    set_fps(41)\n    sleep(50)\n\n    # count in, 4 white flashes then press play on red\n    for _ in range(4):\n        fill(Color.white())\n        sleep(5)\n        fill(Color.black())\n        sleep(15)\n\n    fill(Color.red())\n    sleep(5)\n    fill(Color.black())\n    sleep(15)\n\n    # 8 beat intro thing\n    sleep(4 * 40 + 20)\n\n    for _ in range(8):\n        fill(Color.white())\n        sleep(5)\n        fill(Color.black())\n        sleep(15)\n\n    for _ in range(8):\n        fill(Color.red())\n        sleep(10)\n        fill(Color.green())\n        sleep(10)\n\n\n    for _ in range(8):\n        fill(Color.white())\n        sleep(5)\n        fill(Color.black())\n        sleep(15)\n\n    for _ in range(6):\n        fill(Color.red())\n        sleep(10)\n        fill(Color.green())\n        sleep(10)\n\n    fill(Color.black())\n    for pixel in pixels():\n        if pixel.x &lt; 0:\n            pixel.set_color(Color.white())\n    sleep(10)\n\n    fill(Color.black())\n    for pixel in pixels():\n        if pixel.x &gt; 0:\n            pixel.set_color(Color.white())\n    sleep(10)\n\n    fill(Color.black())\n    for pixel in pixels():\n        if pixel.z &lt; height() / 2:\n            pixel.set_color(Color.white())\n    sleep(10)\n\n    fill(Color.black())\n    for pixel in pixels():\n        if pixel.z &gt; height() / 2:\n            pixel.set_color(Color.white())\n    sleep(10)\n</code></pre>"},{"location":"samples/lerpy/","title":"Lerpy","text":"<pre><code>from gridmas import *\n\nname = \"Lerpy\"\nauthor = \"Ciaran\"\n\n\ndef draw():\n    color = Color.random()\n    while True:\n        for pixel in pixels():\n            pixel.lerp(color, 50, fn=ease_in_out_expo)\n\n        for _ in range(100):\n            yield\n\n        color = Color.different_from(color)\n</code></pre>"},{"location":"samples/off/","title":"off","text":"<pre><code>from gridmas import *\n\nname = \"Off\"\nauthor = \"Ciaran\"\n\n\ndef draw():\n    yield from fizzle()\n\n    set_fps(1)\n</code></pre>"},{"location":"samples/on/","title":"on","text":"<pre><code>from gridmas import *\n\ni = 0\ndef draw():\n    global i\n    for pixel in pixels():\n        if pixel.z &lt; i:\n            pixel.set_rgb(200, 55, 2)\n\n    i += height() / 70\n</code></pre>"},{"location":"samples/planes/","title":"Planes","text":"<pre><code>from gridmas import *\nimport random\n\n\nname = \"Planes\"\nauthor = \"Ciaran\"\n# based on Matt Parkers Xmas tree\n\n\nspeed = RangeAttr(\"speed\", 45, 30, 45, 1)\n\ndef draw():\n    color = Color(255, 255, 0)\n    while True:\n        theta = random.uniform(0, 6.28)\n        alpha = random.uniform(0, 6.28)\n        yield from wipe_frames(theta, alpha, color, int(speed.get()))\n        color = Color.different_from(color)\n</code></pre>"},{"location":"samples/rgb/","title":"RGB","text":"<pre><code>from gridmas import *\n\nname = \"RGB\"\nauthor = \"Ciaran\"\n\nsleep_time = RangeAttr(\"sleep time\", 45, 20, 40, 1)\noffset = 0\n\ndef draw():\n    global sleep_time, offset\n\n\n    if frame() % sleep_time.get() == 0:\n        offset = (offset + 1) % 3\n\n    for i, pixel in enumerate(pixels()):\n        r = 255 if (i + offset) % 3 == 0 else 0\n        g = 255 if (i + offset) % 3 == 1 else 0\n        b = 255 if (i + offset) % 3 == 2 else 0\n        pixel.set_rgb(r, g, b)\n</code></pre>"},{"location":"samples/snowing/","title":"Snowing","text":"<pre><code>from gridmas import *\nimport random\n\n\n\nname = \"Snowing\"\nauthor = \"Ciaran\"\n\n\nclass SnowFlake:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        self.z = height() + 0.2\n        self.yVel = 0.05\n\n\ndef draw():\n    flakes = []\n\n    while True:\n        for _ in range(random.randint(5, 30)):\n\n            flakes = list(filter(lambda x: x.z &gt; -0.2, flakes))\n            fade()\n\n            for flake in flakes:\n                Sphere((flake.x, flake.y, flake.z), 0.2, Color(200, 200, 240))\n                flake.z -= flake.yVel\n                flake.yVel += 0.002\n\n            yield\n\n        flakes.append(SnowFlake(random.random() - 0.5, random.random() - 0.5))\n</code></pre>"},{"location":"samples/spin/","title":"Spin","text":"<pre><code>import math\nfrom gridmas import *\n\nname = \"Spin\"\nauthor = \"Ciaran\"\n# based on Matt Parkers xmas tree\n\nspeed = RangeAttr(\"speed\", 0.02, -0.1, 0.1, 0.001)\ncolor1 = ColorAttr(\"color 1\", Color(0, 50, 50))\ncolor2 = ColorAttr(\"color 2\", Color(50, 50, 0))\n\nheights: list[float] = []\nfor i in coords():\n    heights.append(i[2])\n\nangle = 0\n\n# the starting point on the vertical axis\nc = -height() / 2\n\ndef draw():\n    global angle\n\n    for pixel in pixels():\n        # figure out if the pixel is above or below the plane\n        if (math.tan(angle) * pixel.x &lt;= pixel.z + c) ^ (angle &gt; 0.5 * math.pi) ^ (angle &gt;= 1.5 * math.pi):\n            pixel.set_color(color1.get())\n        else:\n            pixel.set_color(color2.get())\n\n    # now we get ready for the next cycle\n\n    angle = (angle + speed.get()) % (2 * math.pi)\n</code></pre>"},{"location":"samples/strip/","title":"Strip","text":"<pre><code>from gridmas import *\n\nname = \"Strip\"\nauthor = \"Ciaran\"\n\nfade = RangeAttr(\"fade\", 1.1, 1.01, 2, 0.01)\ncolor = ColorAttr(\"Color\", Color.white())\n\ndef draw():\n\n    for pixel in pixels():\n        pixel.set_color(color.get())\n\n        for pixel in pixels():\n            pixel.fade(n=fade.get())\n\n        yield\n</code></pre>"},{"location":"samples/text/","title":"text","text":"<pre><code>import cv2\nfrom gridmas import *\nimport numpy as np\n\nname = \"Text\"\nauthor = \"Ciaran\"\n\n\ndef draw():\n    a = -500\n\n    new_coords = []\n    text = \"(Black screen with text; The sound of buzzing bees can be heard)According to all known laws of aviation, : there is no way a bee should be able to fly. : Its wings are too small to get its fat little body off the ground. : The bee, of course, flies anyway : because bees don't care what humans think is impossible.\"\n    scale = 100\n\n    for pixel in pixels():\n        videox = max(min(int((pixel.x + 1) * scale), scale * 2 - 1), 0)\n        videoy = max(min(int((height() - pixel.z) * scale), int(scale * height() - 1)), 0)\n        new_coords.append((videox, videoy))\n\n    font = cv2.FONT_HERSHEY_SIMPLEX  # Font type\n    font_scale = int(height() * scale * 0.03)  # Font scale (size)\n    font_color = (0, 0, 0)  # Black color in BGR\n    thickness = int(height() * scale * 0.1)  # Thickness of the text\n\n    while True:\n        a += 5\n        blank_image = np.ones((int(scale * height()), int(scale * 2), 3), dtype=np.uint8)\n\n\n\n        # Calculate the center of the image to place the text\n        text_size = cv2.getTextSize(text, font, font_scale, thickness)[0]\n\n        cv2.putText(blank_image, text, (-a, int(scale * height() * 0.8)), font, font_scale, (255, 255, 255), thickness, cv2.LINE_AA)\n        \"\"\"\n        cv2.imshow('Image with Text', blank_image)\n        cv2.waitKey(0)\n        cv2.destroyAllWindows()\n        \"\"\"\n\n        for i, pixel in enumerate(pixels()):\n            value = int(blank_image[new_coords[i][1]][new_coords[i][0]][0])\n            pixel.set_rgb(value, value, value)\n        yield\n</code></pre>"},{"location":"samples/twinkle/","title":"Twinkle","text":"<pre><code>from gridmas import *\nimport random\n\nbaseColor = ColorAttr(\"color\", Color(120, 20, 0))\n\ndef draw():\n    tr, tg, tb = baseColor.get().to_tuple()\n    x = random.randint(0, num_pixels() - 1)\n\n    set_pixel(x, Color.black())\n\n    for pixel in pixels():\n        r, g, b = pixel.to_tuple()\n        pixel.set_rgb(min(int(r + 5), tr), min(int(g + 5), tg), min(int(b + 5), tb))\n</code></pre>"},{"location":"samples/waves/","title":"Waves","text":"<pre><code>from gridmas import *\nimport random\n\n\nname = \"Waves\"\nauthor = \"Ciaran\"\n\nspeed = RangeAttr(\"Speed\", 45, 30, 90, 1)\nlength = RangeAttr(\"Length\", 45, 30, 90, 1)\n\ndef draw():\n    color = Color.random()\n    while True:\n        theta = random.uniform(0, 6.28)\n        alpha = random.uniform(0, 6.28)\n        yield from wipe_wave_frames(theta, alpha, color, int(speed.get()), int(length.get()))\n        color = Color.different_from(color)\n</code></pre>"}]}